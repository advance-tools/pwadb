{"hash":"7946d8fa7ffc2f029694ea8a9301c4b7ed87ec62","fesm2020":{"code":"import { HttpParams } from '@angular/common/http';\nimport { tap, switchMap, timeout, finalize, shareReplay, take, map, catchError, startWith, auditTime, first, distinctUntilChanged, filter as filter$1, mergeMap, concatMap } from 'rxjs/operators';\nimport { Observable, of, combineLatest, from, throwError, BehaviorSubject, Subscription, merge } from 'rxjs';\nimport { addPouchPlugin, addRxPlugin, getRxStoragePouch, createRxDatabase } from 'rxdb';\nimport { RxDBEncryptionPlugin } from 'rxdb/plugins/encryption';\nimport { RxDBLeaderElectionPlugin } from 'rxdb/plugins/leader-election';\nimport { RxDBValidatePlugin } from 'rxdb/plugins/validate';\nimport { RxDBMigrationPlugin } from 'rxdb/plugins/migration';\nimport * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\n\nconst getSchema = (name) => ({\n    title: name + '_store',\n    description: `Store ${name} types of data in the collection`,\n    keyCompression: false,\n    version: 4,\n    type: 'object',\n    primaryKey: 'tenantUrl',\n    properties: {\n        tenantUrl: {\n            type: 'string',\n            primary: true,\n        },\n        matchUrl: {\n            type: 'string',\n        },\n        method: {\n            type: 'string',\n            enum: ['GET', 'POST', 'PUT', 'DELETE'],\n        },\n        data: {\n            type: ['object', 'null'],\n        },\n        time: {\n            type: 'integer',\n        },\n        error: {\n            type: ['string', 'null'],\n        },\n        fileFields: {\n            type: ['array'],\n            default: [],\n            items: {\n                type: ['object'],\n                properties: {\n                    fileField: {\n                        type: ['string']\n                    },\n                    fileNameField: {\n                        type: ['string']\n                    },\n                    fileType: {\n                        type: ['string']\n                    },\n                    fileKeyField: {\n                        type: ['string']\n                    }\n                }\n            }\n        },\n        createdAt: {\n            type: 'integer',\n        },\n        updatedAt: {\n            type: 'integer'\n        }\n    },\n    encrypted: [\n        'data',\n        'fileFields'\n    ],\n});\nconst pwaDocMethods = {};\n\nconst getCollectionCreator = (name, collectionMethods, documentMethods, attachments = {}, options = {}, migrationStrategies = {}, autoMigrate = true) => ({\n    name,\n    schema: getSchema(name),\n    statics: collectionMethods,\n    methods: documentMethods,\n    attachments,\n    options,\n    migrationStrategies: {\n        1: (oldDoc) => {\n            oldDoc.createdAt = new Date().getTime();\n            oldDoc.updatedAt = new Date().getTime();\n            return oldDoc;\n        },\n        2: (oldDoc) => {\n            oldDoc.fileFields = [];\n            return oldDoc;\n        },\n        3: (oldDoc) => {\n            oldDoc.fileFields = [];\n            return oldDoc;\n        },\n        4: (oldDoc) => {\n            oldDoc.fileFields = [];\n            return oldDoc;\n        },\n        ...migrationStrategies\n    },\n    autoMigrate,\n});\nconst pwaCollectionMethods = {};\n\nconst getSynchroniseSchema = () => ({\n    title: 'synchronise_store',\n    description: `Stores database & collectionNames of data in the collection`,\n    keyCompression: false,\n    version: 0,\n    type: 'object',\n    primaryKey: 'id',\n    properties: {\n        id: {\n            type: 'string',\n            primary: true,\n        },\n        databaseOptions: {\n            type: 'string',\n        },\n        collectionName: {\n            type: 'string'\n        },\n        collectionOptions: {\n            type: 'string',\n        },\n        collectionEvictTime: {\n            type: 'integer'\n        },\n        collectionSkipDocuments: {\n            type: 'integer'\n        },\n        collectionReqTitleFieldName: {\n            type: 'string'\n        },\n        collectionReqSubTitleFieldName: {\n            type: ['string', 'null']\n        },\n        collectionReqIconFieldName: {\n            type: ['string', 'null']\n        }\n    },\n    encrypted: [\n        'databaseOptions',\n        'collectionName',\n        'collectionOptions',\n        'collectionEvictTime',\n        'collectionSkipDocuments',\n        'collectionReqTitleFieldName',\n        'collectionReqSubTitleFieldName',\n        'collectionReqIconFieldName',\n    ],\n});\nconst synchroniseDocMethods = {};\n\nconst getSynchroniseCollectionCreator = (name, collectionMethods, documentMethods, attachments = {}, options = {}, migrationStrategies = {}, autoMigrate = true) => ({\n    name,\n    schema: getSynchroniseSchema(),\n    pouchSettings: {\n        revs_limit: 0,\n        auto_compaction: true,\n    },\n    statics: collectionMethods,\n    methods: documentMethods,\n    attachments,\n    options,\n    migrationStrategies,\n    autoMigrate,\n});\nconst synchroniseCollectionMethods = {};\n\nclass CustomEncoder {\n    encodeKey(key) {\n        return encodeURIComponent(key);\n    }\n    encodeValue(value) {\n        return encodeURIComponent(value);\n    }\n    decodeKey(key) {\n        return decodeURIComponent(key);\n    }\n    decodeValue(value) {\n        return decodeURIComponent(value);\n    }\n}\nclass CustomHttpParams extends HttpParams {\n    constructor(options) {\n        options = { ...(options || {}), encoder: new CustomEncoder() };\n        super(options);\n    }\n}\n\nfunction parseNumber(fieldValue, inputValue) {\n    const parsedFieldValue = Number(fieldValue?.toString() || '');\n    const parsedInputValue = Number(inputValue?.toString() || '');\n    return isNaN(parsedFieldValue) && isNaN(parsedInputValue) ? null : { parsedFieldValue, parsedInputValue };\n}\nfunction parseDate(fieldValue, inputValue) {\n    const parsedFieldValue = Date.parse(fieldValue?.toString() || '');\n    const parsedInputValue = Date.parse(inputValue?.toString() || '');\n    return isNaN(parsedFieldValue) && isNaN(parsedInputValue) ? null : { parsedFieldValue, parsedInputValue };\n}\nfunction parseBoolean(fieldValue, inputValue) {\n    const parsedFieldValue = fieldValue?.toString().toLowerCase() === 'true' ? true : fieldValue?.toString().toLowerCase() === 'false' ? false : null;\n    const parsedInputValue = inputValue?.toString().toLowerCase() === 'true' ? true : inputValue?.toString().toLowerCase() === 'false' ? false : null;\n    return parsedFieldValue === null || parsedInputValue === null ? null : { parsedFieldValue, parsedInputValue };\n}\nconst eq = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue === isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue === isNumber.parsedInputValue;\n    }\n    const isBoolean = parseBoolean(v.data[field], inputValue);\n    if (isBoolean) {\n        return isBoolean.parsedFieldValue === isBoolean.parsedInputValue;\n    }\n    return v.data[field] === inputValue;\n};\nconst gte = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue >= isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue >= isNumber.parsedInputValue;\n    }\n    return v.data[field] >= inputValue;\n};\nconst lte = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue <= isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue <= isNumber.parsedInputValue;\n    }\n    return v.data[field] <= inputValue;\n};\nconst gt = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue > isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue > isNumber.parsedInputValue;\n    }\n    return v.data[field] > inputValue;\n};\nconst lt = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue < isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue < isNumber.parsedInputValue;\n    }\n    return v.data[field] < inputValue;\n};\nconst range = (v, field, inputValue) => {\n    const values = inputValue.toString().split(',');\n    const isDate1 = parseDate(v.data[field], values[0]);\n    const isDate2 = parseDate(v.data[field], values[1]);\n    if (isDate1 && isDate2) {\n        return isDate1.parsedFieldValue >= isDate1.parsedInputValue && isDate2.parsedFieldValue < isDate2.parsedInputValue;\n    }\n    const isNumber1 = parseNumber(v.data[field], values[0]);\n    const isNumber2 = parseNumber(v.data[field], values[1]);\n    if (isNumber1 && isNumber2) {\n        return isNumber1.parsedFieldValue >= isNumber1.parsedInputValue && isNumber2.parsedFieldValue < isNumber2.parsedInputValue;\n    }\n    return v.data[field] >= values[0] && v.data[field] < values[1];\n};\nconst startswith = (v, field, inputValue) => v.data[field]?.toString().startsWith(inputValue);\nconst endswith = (v, field, inputValue) => v.data[field]?.toString().endsWith(inputValue);\nconst iexact = (v, field, inputValue) => !!v.data[field]?.toString().match(new RegExp(`^${inputValue}$`, 'i'));\nconst exact = (v, field, inputValue) => !!v.data[field]?.toString().match(new RegExp(`^${inputValue}$`));\nconst icontains = (v, field, inputValue) => v.data[field]?.toString().toLowerCase().includes(inputValue?.toLowerCase() || '');\nconst contains = (v, field, inputValue) => v.data[field]?.toString().includes(inputValue);\nconst isnull = (v, field, inputValue) => inputValue?.toLowerCase() === 'true' ? v.data[field] === null : v.data[field] !== null;\nfunction getQuery(key, value) {\n    if (key.includes('distinct')) {\n        return { queryType: 'distinct', fields: value.split(',') };\n    }\n    else if (key.includes('only')) {\n        return { queryType: 'only', fields: value.split(',') };\n    }\n    else if (key.includes('ordering')) {\n        return { queryType: 'ordering', fields: value.split(',') };\n    }\n    else if (key.includes('exclude')) {\n        const fieldAndLookup = key.split(':')[1].split('.');\n        return { queryType: 'exclude', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] : 'eq', inputValue: value };\n    }\n    else if (key.includes('filter')) {\n        const fieldAndLookup = key.split(':')[1].split('.');\n        return { queryType: 'filter', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] : 'eq', inputValue: value };\n    }\n    else {\n        const fieldAndLookup = key.split('.');\n        return { queryType: 'filter', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] : 'eq', inputValue: value };\n    }\n}\nfunction queryFilter(validQueryKeys, params, docs) {\n    if (params) {\n        const keys = params.keys();\n        keys.forEach(k => {\n            if (validQueryKeys.indexOf(k) > -1) {\n                const query = getQuery(k, params.getAll(k).join(','));\n                if (query.queryType === 'filter') {\n                    docs = filter(query.fields[0], query.inputValue, docs, query.lookup);\n                }\n            }\n        });\n        keys.forEach(k => {\n            if (validQueryKeys.indexOf(k) > -1) {\n                const query = getQuery(k, params.getAll(k).join(','));\n                if (query.queryType === 'exclude') {\n                    docs = exclude(query.fields[0], query.inputValue, docs, query.lookup);\n                }\n            }\n        });\n        keys.forEach(k => {\n            if (validQueryKeys.indexOf(k) > -1) {\n                const query = getQuery(k, params.getAll(k).join(','));\n                if (query.queryType === 'ordering') {\n                    docs = orderBy(query.fields, docs);\n                }\n            }\n        });\n        keys.forEach(k => {\n            if (validQueryKeys.indexOf(k) > -1) {\n                const query = getQuery(k, params.getAll(k).join(','));\n                if (query.queryType === 'distinct') {\n                    docs = distinct(query.fields, docs);\n                }\n            }\n        });\n    }\n    return docs;\n}\nfunction filter(field, inputValue, docs, lookup, isExclude = false) {\n    let f = (v) => inputValue.split(',').reduce((acc, cur) => acc || eq(v, field, cur), false);\n    if (lookup === 'gte') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || gte(v, field, cur), false);\n    }\n    if (lookup === 'lte') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || lte(v, field, cur), false);\n    }\n    if (lookup === 'gt') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || gt(v, field, cur), false);\n    }\n    if (lookup === 'lt') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || lt(v, field, cur), false);\n    }\n    if (lookup === 'range') {\n        f = v => range(v, field, inputValue);\n    }\n    if (lookup === 'startswith') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || startswith(v, field, cur), false);\n    }\n    if (lookup === 'endswith') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || endswith(v, field, cur), false);\n    }\n    if (lookup === 'iexact') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || iexact(v, field, cur), false);\n    }\n    if (lookup === 'exact') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || exact(v, field, cur), false);\n    }\n    if (lookup === 'icontains') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || icontains(v, field, cur), false);\n    }\n    if (lookup === 'contains') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || contains(v, field, cur), false);\n    }\n    if (lookup === 'isnull') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || isnull(v, field, cur), false);\n    }\n    return docs.filter((v) => {\n        const o = f(v);\n        return isExclude ? !o : o;\n    });\n}\nfunction exclude(field, inputValue, docs, lookup) {\n    return filter(field, inputValue, docs, lookup, true);\n}\nfunction distinct(fields, docs) {\n    const uniques = new Set();\n    const distinctArray = [];\n    docs.forEach(v => {\n        const key = fields.reduce((acc, cur) => acc += `-${v.data[cur]?.toString() || 'null'}`, '');\n        if (!uniques.has(key)) {\n            uniques.add(key);\n            distinctArray.push(v);\n        }\n    });\n    return distinctArray;\n}\nfunction orderBy(fields, docs) {\n    return docs.sort((a, b) => {\n        for (let i = 0; i < fields.length; i++) {\n            const order = fields[i].indexOf('-') === 0 ? 'desc' : 'asc';\n            const parseFieldName = order === 'desc' ? fields[i].split('-')[1] : fields[i];\n            if (!(parseFieldName in a?.data) || !(parseFieldName in b?.data)) {\n                continue;\n            }\n            let output = 0;\n            const isDate = parseDate(a.data[parseFieldName], b.data[parseFieldName]);\n            if (isDate && order === 'asc' && isDate.parsedFieldValue !== isDate.parsedInputValue) {\n                output = isDate.parsedFieldValue - isDate.parsedInputValue;\n                if (output > 0 || output < 0) {\n                    return output;\n                }\n            }\n            if (isDate && order === 'desc' && isDate.parsedInputValue !== isDate.parsedFieldValue) {\n                output = isDate.parsedInputValue - isDate.parsedFieldValue;\n                if (output > 0 || output < 0) {\n                    return output;\n                }\n            }\n            const isNumber = parseNumber(a.data[parseFieldName], b.data[parseFieldName]);\n            if (isNumber && order === 'asc' && isNumber.parsedFieldValue !== isNumber.parsedInputValue) {\n                output = isNumber.parsedFieldValue - isNumber.parsedInputValue;\n                if (output > 0 || output < 0) {\n                    return output;\n                }\n            }\n            if (isNumber && order === 'desc' && isNumber.parsedInputValue !== isNumber.parsedFieldValue) {\n                output = isNumber.parsedInputValue - isNumber.parsedFieldValue;\n                if (output > 0 || output < 0) {\n                    return output;\n                }\n            }\n            const valueA = a.data[parseFieldName]?.toString() || '';\n            const valueB = b.data[parseFieldName]?.toString() || '';\n            output = order === 'asc' ? valueA.localeCompare(valueB) : valueA.localeCompare(valueB) * -1;\n            if (output > 0 || output < 0) {\n                return output;\n            }\n        }\n        return 0;\n    });\n}\n\nfunction enterZone(zone) {\n    return (source) => new Observable(observer => source.subscribe({\n        next: (x) => zone.run(() => observer.next(x)),\n        error: (err) => observer.error(err),\n        complete: () => observer.complete()\n    }));\n}\n\nclass RestAPI {\n    constructor(config) {\n        this.config = config;\n        this.cache = new Map();\n    }\n    get(url, params) {\n        const paramsUrl = params?.keys().map(k => `${k}=${params.getAll(k).join(',')}`).join('&');\n        const cacheKey = `${url}${paramsUrl ? '?' + paramsUrl : ''}`;\n        const req = of(true).pipe(tap(() => { if (!!this.config.apiProgress) {\n            this.config.apiProgress.add();\n        } }), switchMap(() => this.config.httpClient.get(cacheKey)), timeout(7500), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n    post(url, data) {\n        const cacheKey = url;\n        const req = of(true).pipe(tap(() => { if (!!this.config.apiProgress) {\n            this.config.apiProgress.add();\n        } }), switchMap(() => this.config.httpClient.post(url, data)), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n    put(url, data) {\n        const cacheKey = url;\n        const req = of(true).pipe(tap(() => { if (!!this.config.apiProgress) {\n            this.config.apiProgress.add();\n        } }), switchMap(() => this.config.httpClient.put(url, data)), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n    list(url, params) {\n        const paramsUrl = params?.keys().map(k => `${k}=${params.getAll(k).join(',')}`).join('&');\n        const cacheKey = `${url}${paramsUrl ? '?' + paramsUrl : ''}`;\n        const req = of(true).pipe(tap(() => { if (!!this.config.apiProgress) {\n            this.config.apiProgress.add();\n        } }), switchMap(() => this.config.httpClient.get(cacheKey)), timeout(7500), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n    delete(url) {\n        const cacheKey = url;\n        const req = of(true).pipe(tap(() => { if (!!this.config.apiProgress) {\n            this.config.apiProgress.add();\n        } }), switchMap(() => this.config.httpClient.delete(url)), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n}\nclass CollectionAPI {\n    constructor(_config) {\n        this._config = _config;\n        this.config = {\n            name: 'no_name_collection_api',\n            db$: of(),\n            collectionEvictTime$: of(86400),\n            collectionSkipDocuments$: of(500),\n            attachments: {},\n            options: {},\n            migrationStrategies: {},\n            autoMigrate: true,\n            ngZone: null\n        };\n        this.cache = new Map();\n        this.config = {\n            ...this.config,\n            ...this._config\n        };\n    }\n    get collection$() {\n        if (this._collection$) {\n            return this._collection$;\n        }\n        const collectionSchema = {};\n        collectionSchema[this.config.name] = getCollectionCreator(this.config.name, pwaCollectionMethods, pwaDocMethods, this.config.attachments, this.config.options, this.config.migrationStrategies, this.config.autoMigrate);\n        this._collection$ = this.config.db$.pipe(switchMap(db => {\n            if (this.config.name in db) {\n                return of(db[this.config.name]);\n            }\n            return combineLatest([\n                from(db.addCollections(collectionSchema)),\n                this.config.collectionEvictTime$,\n                this.config.collectionSkipDocuments$\n            ]).pipe(take(1), switchMap(([collections, collectionEvictTime, collectionSkipDocuments]) => {\n                if (this.config.synchroniseService) {\n                    const data = {\n                        id: db.name + '-' + this.config.name,\n                        databaseOptions: JSON.stringify({\n                            name: db.name,\n                            eventReduce: db.eventReduce,\n                            multiInstance: db.multiInstance,\n                            options: db.options,\n                            password: db.password,\n                        }),\n                        collectionEvictTime,\n                        collectionSkipDocuments,\n                        collectionName: this.config.name,\n                        collectionOptions: JSON.stringify({\n                            name: this.config.name,\n                            schema: getSchema(this.config.name),\n                            attachments: collections[this.config.name].attachments,\n                            autoMigrate: true,\n                            cacheReplacementPolicy: collections[this.config.name].cacheReplacementPolicy,\n                            methods: collections[this.config.name].methods,\n                            migrationStrategies: collections[this.config.name].migrationStrategies,\n                            options: collections[this.config.name].options,\n                            statics: collections[this.config.name].statics,\n                        })\n                    };\n                    return this.config.synchroniseService.addSynchroniseDocument(data).pipe(map(() => collections[this.config.name]));\n                }\n                else {\n                    return of(collections).pipe(map(() => collections[this.config.name]));\n                }\n            }));\n        }), tap(col => col.preSave((plainData, rxDocument) => {\n            plainData.createdAt = plainData.createdAt || new Date().getTime();\n            plainData.updatedAt = new Date().getTime();\n        }, false)), shareReplay(1), take(1));\n        return this._collection$;\n    }\n    makeTenantUrl(tenant, url) {\n        return `${tenant}____${url}`;\n    }\n    filterDocs(docs, url, params, validQueryKeys = []) {\n        return docs.pipe(map(allDocs => queryFilter(validQueryKeys, params, allDocs)), map(allDocs => {\n            const start = parseInt(params?.get('offset') || '0');\n            const end = start + parseInt(params?.get('limit') || '100');\n            const next = allDocs.length - end > 0 ? `${url}?${params.set('offset', end.toString()).toString()}` : null;\n            const previous = start > 0 ? `${url}?${params.set('offset', start.toString()).toString()}` : null;\n            return { next, previous, results: allDocs.slice(start, end), count: allDocs.length };\n        }));\n    }\n    getReactive(tenant, url) {\n        const cacheKey = tenant + url;\n        if (!this.cache.has(cacheKey)) {\n            const doc = this.collection$.pipe(switchMap(col => col.findOne({ selector: { tenantUrl: { $eq: this.makeTenantUrl(tenant, url) } } }).$), shareReplay(1), enterZone(this.config.ngZone));\n            this.cache.set(cacheKey, doc);\n        }\n        return this.cache.get(cacheKey);\n    }\n    get(tenant, url) {\n        return this.getReactive(tenant, url).pipe(take(1));\n    }\n    listReactive(tenant, url, params, validQueryKeys = []) {\n        const cacheKey = tenant + url;\n        if (!this.cache.has(cacheKey)) {\n            const docs = this.collection$.pipe(switchMap(col => col.find({ selector: { matchUrl: { $regex: new RegExp(`^${this.makeTenantUrl(tenant, url)}.*`) } } }).$), shareReplay(1));\n            this.cache.set(cacheKey, docs);\n        }\n        return this.filterDocs(this.cache.get(cacheKey), url, params, validQueryKeys).pipe(enterZone(this.config.ngZone));\n    }\n    list(tenant, url, params, validQueryKeys = []) {\n        return this.listReactive(tenant, url, params, validQueryKeys).pipe(take(1));\n    }\n    post(tenant, url, data, fileFields = []) {\n        return this.collection$.pipe(switchMap(col => col.atomicUpsert({\n            tenantUrl: `${this.makeTenantUrl(tenant, url)}/${data.id}`,\n            matchUrl: `${this.makeTenantUrl(tenant, url)}/${data.id}`,\n            method: 'POST',\n            data,\n            error: null,\n            time: new Date().getTime(),\n            fileFields\n        })));\n    }\n    put(tenant, url, data, fileFields = []) {\n        return combineLatest([this.get(tenant, url), this.collection$]).pipe(switchMap(([doc, col]) => {\n            if (doc) {\n                return doc.atomicPatch({\n                    method: doc.method !== 'POST' ? 'PUT' : doc.method,\n                    data,\n                    error: null,\n                    time: doc.method === 'GET' ? new Date().getTime() : doc.time,\n                    fileFields\n                });\n            }\n            else {\n                const docData = {\n                    tenantUrl: this.makeTenantUrl(tenant, url),\n                    matchUrl: this.makeTenantUrl(tenant, url),\n                    data,\n                    method: 'PUT',\n                    error: null,\n                    time: new Date().getTime(),\n                    fileFields\n                };\n                return col.atomicUpsert(docData);\n            }\n        }));\n    }\n    delete(tenant, url, data, fileFields = []) {\n        return this.get(tenant, url).pipe(switchMap(doc => {\n            if (doc && doc.method === 'POST') {\n                return from(doc.remove());\n            }\n            else if (doc && (doc.method === 'PUT' || doc.method === 'DELETE')) {\n                return from(doc.atomicPatch({ method: 'DELETE', error: null }));\n            }\n            else if (doc) {\n                return from(doc.atomicPatch({ method: 'DELETE', error: null, time: new Date().getTime() }));\n            }\n            else if (data) {\n                const docData = {\n                    tenantUrl: this.makeTenantUrl(tenant, url),\n                    matchUrl: this.makeTenantUrl(tenant, url),\n                    data,\n                    method: 'DELETE',\n                    error: null,\n                    time: new Date().getTime(),\n                    fileFields\n                };\n                return this.collection$.pipe(switchMap(col => col.atomicUpsert(docData)));\n            }\n            else {\n                return throwError('Document not found while deleting in database');\n            }\n        }));\n    }\n    createNew(tenant, url) {\n        return this.get(tenant, url).pipe(switchMap(doc => {\n            if (!!doc && doc.method !== 'GET' && doc.method !== 'POST') {\n                return from(doc.atomicPatch({ method: 'POST' }));\n            }\n            return throwError(`Cannot duplicate this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n        }));\n    }\n    deleteConflict(tenant, url) {\n        return this.get(tenant, url).pipe(switchMap(doc => {\n            if (!!doc && doc.method !== 'GET') {\n                return from(doc.remove());\n            }\n            return throwError(`Cannot delete this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n        }));\n    }\n}\nclass PwaCollectionAPI {\n    constructor(_config) {\n        this._config = _config;\n        this.config = {\n            restApiCreator: {},\n            collectionApiCreator: {\n                name: 'no_name_pwa_collection_api',\n                db$: of(),\n                collectionEvictTime$: of(86400),\n                collectionSkipDocuments$: of(500),\n                attachments: {},\n                options: {},\n                migrationStrategies: {},\n                autoMigrate: true,\n            },\n            cacheTimeInSeconds: 120\n        };\n        this.config = {\n            ...this.config,\n            ...this._config,\n            restApiCreator: {\n                ...this.config.restApiCreator,\n                ...this._config.restApiCreator\n            },\n            collectionApiCreator: {\n                ...this.config.collectionApiCreator,\n                ...this._config.collectionApiCreator\n            }\n        };\n        this.restAPI = new RestAPI(this.config.restApiCreator);\n        this.collectionAPI = new CollectionAPI(this.config.collectionApiCreator);\n    }\n    downloadRetrieve(doc, tenant, url, params) {\n        if (!!doc && doc.method !== 'GET') {\n            return of(doc);\n        }\n        const currentTime = new Date().getTime();\n        if (!!doc && doc.time >= (currentTime - (this.config.cacheTimeInSeconds * 1000))) {\n            return of(doc);\n        }\n        return combineLatest([this.restAPI.get(url, params), this.collectionAPI.collection$]).pipe(switchMap(([res, col]) => col.atomicUpsert({\n            tenantUrl: this.collectionAPI.makeTenantUrl(tenant, url),\n            matchUrl: this.collectionAPI.makeTenantUrl(tenant, url),\n            data: res,\n            method: 'GET',\n            error: null,\n            time: new Date().getTime(),\n        })), catchError(() => of(doc)));\n    }\n    getReactive(tenant, url, params, wait = false) {\n        return this.collectionAPI.get(tenant, url).pipe(switchMap(doc => wait ?\n            this.downloadRetrieve(doc, tenant, url, params) :\n            this.downloadRetrieve(doc, tenant, url, params).pipe(startWith(null))), switchMap(() => this.collectionAPI.getReactive(tenant, url)), auditTime(1000 / 60));\n    }\n    get(tenant, url, params) {\n        return this.getReactive(tenant, url, params, true).pipe(take(1));\n    }\n    downloadList(res, tenant, url, params, indexedbUrl = (data, tenantUrl) => `${tenantUrl}/${data.id}`) {\n        const currentTime = new Date().getTime();\n        const limit = parseInt(params?.get('limit') || '100');\n        const ids = res.results\n            .filter(v => v.method === 'PUT' || v.method === 'DELETE' || (v.method === 'GET' && v.time >= (currentTime - (this.config.cacheTimeInSeconds * 1000))))\n            .map(v => v.data.id);\n        if (ids.length === limit) {\n            return of({ next: res.next, previous: res.previous, results: [] });\n        }\n        params = params || new CustomHttpParams();\n        if (ids.length > 0) {\n            if (params.has('exclude:id.in')) {\n                params.delete('exclude:id.in');\n            }\n            params = params.append('exclude:id.in', ids.join(','));\n            params = params.set('limit', (limit - ids.length).toString());\n        }\n        return this.restAPI.list(url, params).pipe(catchError(() => of({ next: null, previous: null, results: [] })), switchMap(networkRes => this.collectionAPI.collection$.pipe(switchMap(col => {\n            const atomicWrites = networkRes.results\n                .map(data => ({\n                tenantUrl: indexedbUrl(data, this.collectionAPI.makeTenantUrl(tenant, url)),\n                matchUrl: indexedbUrl(data, this.collectionAPI.makeTenantUrl(tenant, url)),\n                data,\n                method: 'GET',\n                error: null,\n                time: new Date().getTime(),\n            }));\n            if (atomicWrites.length > 0) {\n                return from(col.bulkInsert(atomicWrites)).pipe(map(() => networkRes));\n            }\n            return of(networkRes);\n        }))));\n    }\n    listReactive(tenant, url, params, validQueryKeys = [], indexedbUrl = (data, tenantUrl) => `${tenantUrl}/${data.id}`, wait = false) {\n        return this.collectionAPI.list(tenant, url, params, validQueryKeys).pipe(switchMap(idbRes => wait ?\n            this.downloadList(idbRes, tenant, url, params, indexedbUrl) :\n            this.downloadList(idbRes, tenant, url, params, indexedbUrl).pipe(startWith({ next: null, previous: null, results: [] }))), switchMap((networkRes) => this.collectionAPI.listReactive(tenant, url, params, validQueryKeys).pipe(map(res => ({\n            next: networkRes?.next || res.next,\n            previous: networkRes?.previous || res.previous,\n            results: res.results\n        })))));\n    }\n    list(tenant, url, params, validQueryKeys = [], indexedbUrl = (data, tenantUrl) => `${tenantUrl}/${data.id}`) {\n        return this.listReactive(tenant, url, params, validQueryKeys, indexedbUrl, true).pipe(take(1));\n    }\n}\n\naddPouchPlugin(require('pouchdb-adapter-idb'));\nclass PwaDatabaseService {\n    constructor(_config) {\n        this._config = _config;\n    }\n    get db$() {\n        if (this._db$) {\n            return this._db$;\n        }\n        addRxPlugin(RxDBEncryptionPlugin);\n        addRxPlugin(RxDBLeaderElectionPlugin);\n        addRxPlugin(RxDBValidatePlugin);\n        addRxPlugin(RxDBMigrationPlugin);\n        const pouchAdapter = getRxStoragePouch('idb');\n        pouchAdapter.pouchSettings.revs_limit = 0,\n            pouchAdapter.pouchSettings.auto_compaction = true;\n        this._db$ = from(createRxDatabase({\n            name: 'pwadb',\n            storage: pouchAdapter,\n            password: 'ubT6LIL7ne2bdpze0V1DaeOGKKqYMWVF',\n            multiInstance: true,\n            eventReduce: true,\n            ...this._config.dbCreator\n        })).pipe(switchMap((db) => from(db.waitForLeadership()).pipe(startWith(null), map(() => db))), shareReplay(1), first());\n        return this._db$;\n    }\n}\n\nclass ApiProgressService {\n    constructor(zone) {\n        this.zone = zone;\n        this.progress = new BehaviorSubject([]);\n        this.isProgressing$ = this.progress.asObservable().pipe(map(v => !!v.length), distinctUntilChanged(), auditTime(1000 / 60), enterZone(zone));\n    }\n    add() {\n        const newProgress = this.progress.value;\n        newProgress.push(true);\n        this.progress.next(newProgress);\n    }\n    remove() {\n        if (this.isProgressing()) {\n            const newProgress = this.progress.value;\n            newProgress.pop();\n            this.progress.next(newProgress);\n        }\n    }\n    isProgressing() {\n        return !!this.progress.value.length;\n    }\n}\nApiProgressService.ɵfac = function ApiProgressService_Factory(t) { return new (t || ApiProgressService)(i0.ɵɵinject(i0.NgZone)); };\nApiProgressService.ɵprov = i0.ɵɵdefineInjectable({ token: ApiProgressService, factory: ApiProgressService.ɵfac, providedIn: 'root' });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ApiProgressService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: i0.NgZone }]; }, null); })();\n\nfunction flatten(arr, result = []) {\n    for (let i = 0, length = arr.length; i < length; i++) {\n        const value = arr[i];\n        if (Array.isArray(value)) {\n            flatten(value, result);\n        }\n        else {\n            result.push(value);\n        }\n    }\n    return result;\n}\n\nclass BaseDatabase {\n    constructor(__limit, __zone) {\n        this.__limit = __limit;\n        this.__zone = __zone;\n        this.data = [];\n        this.queueChange = new BehaviorSubject([]);\n        this._isLoadingChange = new BehaviorSubject(false);\n        this._httpParams = new CustomHttpParams();\n        this.isLoadingChange = this._isLoadingChange.asObservable().pipe(distinctUntilChanged(), enterZone(this.__zone));\n    }\n    get httpParams() { return this._httpParams; }\n    set httpParams(v) {\n        this._httpParams = v;\n        this.reset();\n    }\n    get isLoading() { return this._isLoadingChange.value; }\n    get offset() { return this.data.length; }\n    get isLoadable() { return !!this.lastRes?.next; }\n    get limit() { return this.__limit; }\n    reset() {\n        this._httpParams = this.httpParams.delete('cursor');\n        this._httpParams = this.httpParams.set('offset', '0');\n        this._httpParams = this.httpParams.set('limit', this.limit.toString());\n        if (!this.httpParams.has('ordering')) {\n            this._httpParams = this.httpParams.set('ordering', '-created_at');\n        }\n    }\n    loadMore() {\n        if (this.lastRes?.next) {\n            const split = this.lastRes.next.split('?');\n            if (split.length > 1) {\n                split[1].split('&').forEach(q => {\n                    const queryParam = q.split('=');\n                    this._httpParams = this.httpParams.set(decodeURIComponent(queryParam[0]), decodeURIComponent(queryParam[1]));\n                });\n            }\n        }\n        this._httpParams = this.httpParams.set('offset', this.offset.toString());\n        this._httpParams = this.httpParams.set('limit', this.limit.toString());\n    }\n}\nclass Database extends BaseDatabase {\n    constructor(apiService, zone, _limit = 20) {\n        super(_limit, zone);\n        this.apiService = apiService;\n        this.zone = zone;\n        this._limit = _limit;\n        this.dataChange = this.queueChange.asObservable().pipe(tap(v => { if (!v.length) {\n            this.reset();\n        } }), filter$1(v => !!v.length), tap(() => this._isLoadingChange.next(true)), switchMap(v => combineLatest(v)), auditTime(1000 / 60), tap(res => this.lastRes = res.length > 0 ? res[res.length - 1] : null), map(res => flatten(res.map(v => v.results))), tap(v => this.data = v), tap(() => this._isLoadingChange.next(false)), shareReplay(1));\n    }\n    getView(httpParams) {\n        return this.apiService.fetch(httpParams).pipe(shareReplay(1));\n    }\n    reset() {\n        super.reset();\n        const view = this.getView(this.httpParams);\n        this.queueChange.next([view]);\n    }\n    loadMore() {\n        if (this.isLoading) {\n            return;\n        }\n        super.loadMore();\n        const view = this.getView(this.httpParams);\n        this.queueChange.next(flatten([this.queueChange.value, view]));\n    }\n}\nclass ReactiveDatabase extends BaseDatabase {\n    constructor(apiService, zone, _limit = 20) {\n        super(_limit, zone);\n        this.apiService = apiService;\n        this.zone = zone;\n        this._limit = _limit;\n        this.dataChange = this.queueChange.asObservable().pipe(tap(v => { if (!v.length) {\n            this.reset();\n        } }), filter$1(v => !!v.length), tap(() => this._isLoadingChange.next(true)), switchMap(v => combineLatest(v)), auditTime(1000 / 60), tap(res => this.lastRes = res.length > 0 ? res[res.length - 1] : null), map(res => flatten(res.map(v => v.results))), tap(v => this.data = v), tap(() => this._isLoadingChange.next(false)), shareReplay(1));\n    }\n    getView(httpParams) {\n        return this.apiService.fetchReactive(httpParams).pipe(shareReplay(1));\n    }\n    reset() {\n        super.reset();\n        const view = this.getView(this.httpParams);\n        this.queueChange.next([view]);\n    }\n    loadMore() {\n        if (this.isLoading) {\n            return;\n        }\n        super.loadMore();\n        const view = this.getView(this.httpParams);\n        this.queueChange.next(flatten([this.queueChange.value, view]));\n    }\n}\n\nclass TreeDatabase {\n    constructor(treeInfo) {\n        this.treeInfo = treeInfo;\n        this.databaseMap = new Map();\n        this.databaseKeyMap = new Map();\n        this.childTreeMap = new Map();\n        this._httpParams = new CustomHttpParams();\n        this.queueChange = new BehaviorSubject(true);\n        this.dataChange = this.queueChange.asObservable().pipe(switchMap(() => this.buildTree(this.treeInfo, null, this.httpParams)), shareReplay(1));\n    }\n    get httpParams() { return this._httpParams; }\n    set httpParams(v) {\n        this._httpParams = v;\n        this.reset();\n    }\n    buildTree(treeInfo, parentDoc = null, parentParams = new CustomHttpParams(), parentKey = null) {\n        const treeNodes = Object.keys(treeInfo).map(key => {\n            const db = treeInfo[key].getDatabase();\n            const currentDatabaseMapKey = parentKey && parentDoc ? `${parentKey}~${parentDoc.tenantUrl}--${key}` : key;\n            this.databaseKeyMap.set(currentDatabaseMapKey, db);\n            const possibleParamKeys = parentParams.keys().filter(pk => pk && pk.includes(`${key}--`));\n            let currentParams = new CustomHttpParams();\n            possibleParamKeys.forEach(pk => {\n                const paramName = pk.split(`${key}--`)[1];\n                if (!paramName.includes('--')) {\n                    currentParams = currentParams.set(paramName, parentParams.get(pk));\n                }\n            });\n            treeInfo[key].onCreationSetup ? treeInfo[key].onCreationSetup(parentDoc, db, currentParams) : db.httpParams = currentParams;\n            return db.dataChange.pipe(map(docs => {\n                const obsArr = docs.map(doc => {\n                    if (!this.databaseMap.has(doc)) {\n                        this.databaseMap.set(doc, db);\n                    }\n                    if (!this.childTreeMap.has(doc)) {\n                        if (treeInfo[key].isRecursive) {\n                            treeInfo[key].children[key] = treeInfo[key];\n                        }\n                        const childTree = this.buildTree(treeInfo[key].children, doc, parentParams, currentDatabaseMapKey).pipe(shareReplay(1));\n                        this.childTreeMap.set(doc, { item: doc, children: childTree });\n                    }\n                    return this.childTreeMap.get(doc);\n                });\n                return obsArr;\n            }));\n        });\n        return combineLatest(treeNodes).pipe(map(nodes => flatten(nodes)));\n    }\n    reset() {\n        this.databaseMap.clear();\n        this.databaseKeyMap.clear();\n        this.childTreeMap.clear();\n        this.queueChange.next(true);\n    }\n}\nclass DynamicFlatNode {\n    constructor(item, level = 1, expandable = false) {\n        this.item = item;\n        this.level = level;\n        this.expandable = expandable;\n    }\n}\nclass DynamicTreeFlattener {\n    constructor(transformFunction, getLevel, isExpandable, getChildren) {\n        this.transformFunction = transformFunction;\n        this.getLevel = getLevel;\n        this.isExpandable = isExpandable;\n        this.getChildren = getChildren;\n        this.flatNodeMap = new Map();\n        this.structuredNodeMap = new Map();\n        this.parentNodeMap = new Map();\n    }\n    _flattenNode(node, level) {\n        if (!this.flatNodeMap.has(node)) {\n            const flatNode = this.transformFunction(node, level);\n            this.flatNodeMap.set(node, flatNode);\n            this.structuredNodeMap.set(flatNode, node);\n        }\n        return this.flatNodeMap.get(node);\n    }\n    insertChildrenFlatNodes(parentNode, children, resultNodes) {\n        const index = resultNodes.indexOf(parentNode);\n        resultNodes.splice(index + 1, 0, ...children);\n        children.filter(c => !this.parentNodeMap.has(c)).forEach(c => this.parentNodeMap.set(c, parentNode));\n        return resultNodes;\n    }\n    removeChildrenFlatNodes(parentNode, resultNodes) {\n        const index = resultNodes.indexOf(parentNode);\n        let count = 0;\n        for (let i = index + 1; i < resultNodes.length && this.getLevel(resultNodes[i]) > this.getLevel(parentNode); i++, count++) { }\n        const children = resultNodes.splice(index + 1, count);\n        children.filter(c => this.parentNodeMap.has(c)).forEach(c => this.parentNodeMap.delete(c));\n        return resultNodes;\n    }\n    addChildrenFlatNode(parentFlatNode, resultNodes) {\n        const structuredNode = this.structuredNodeMap.get(parentFlatNode);\n        const structuredChildrenNodes = this.getChildren(structuredNode);\n        if (structuredChildrenNodes) {\n            if (Array.isArray(structuredChildrenNodes)) {\n                const flatChildren = structuredChildrenNodes.map(s => this._flattenNode(s, this.getLevel(parentFlatNode) + 1));\n                return of(this.insertChildrenFlatNodes(parentFlatNode, flatChildren, resultNodes));\n            }\n            else {\n                return structuredChildrenNodes.pipe(map(children => children.map(s => this._flattenNode(s, this.getLevel(parentFlatNode) + 1))), map(flatChildren => {\n                    resultNodes = this.removeChildrenFlatNodes(parentFlatNode, resultNodes);\n                    return this.insertChildrenFlatNodes(parentFlatNode, flatChildren, resultNodes);\n                }));\n            }\n        }\n        return of(resultNodes);\n    }\n    flattenNodes(structuredData) {\n        return structuredData.map(node => this._flattenNode(node, 0));\n    }\n}\nclass DynamicFlatTreeDataSource {\n    constructor(_treeControl, _treeFlattener, initialData) {\n        this._treeControl = _treeControl;\n        this._treeFlattener = _treeFlattener;\n        this._flattenedData = new BehaviorSubject([]);\n        this._data = new BehaviorSubject([]);\n        this.subs = new Subscription();\n        if (initialData) {\n            this.data = initialData;\n        }\n    }\n    get data() { return this._data.value; }\n    set data(value) {\n        this._data.next(value);\n        const flattenedData = this._treeFlattener.flattenNodes(this.data);\n        this._treeControl.expansionModel.clear();\n        this._treeControl.dataNodes = flattenedData;\n        this.flattenedData = flattenedData;\n    }\n    mergeData(value) {\n        this._data.next(value);\n        const flattenedData = this._treeFlattener.flattenNodes(this.data);\n        const mergeObj = {};\n        this.flattenedData.concat(flattenedData).forEach(f => mergeObj[f.id] = f);\n        const mergedFlattenedData = Object.values(mergeObj);\n        this._treeControl.dataNodes = mergedFlattenedData;\n        this.flattenedData = mergedFlattenedData;\n    }\n    get flattenedData() { return this._flattenedData.value; }\n    set flattenedData(v) { this._flattenedData.next(v); }\n    toggleNode(flatNode, expand) {\n        if (expand) {\n            if (this._treeFlattener.isExpandable(flatNode)) {\n                return this._treeFlattener.addChildrenFlatNode(flatNode, this.flattenedData);\n            }\n            return this._flattenedData.asObservable();\n        }\n        else {\n            return of(this._treeFlattener.removeChildrenFlatNodes(flatNode, this.flattenedData));\n        }\n    }\n    handleTreeControl(change) {\n        if (change.added) {\n            const obsArray = change.added.map(node => this.toggleNode(node, true));\n            return combineLatest(obsArray).pipe(map((o) => o.length > 0 ? o[obsArray.length - 1] : []));\n        }\n        if (change.removed) {\n            const obsArray = change.removed.slice().reverse().map(node => this.toggleNode(node, false));\n            return combineLatest(obsArray).pipe(map((o) => o.length > 0 ? o[obsArray.length - 1] : []));\n        }\n    }\n    connect(collectionViewer) {\n        const changeObs = this._treeControl.expansionModel.changed.pipe(filter$1(change => !!change.added?.length || !!change.removed?.length), mergeMap(change => this.handleTreeControl(change)), auditTime(1000 / 60));\n        const subs = changeObs.subscribe((v) => {\n            this._treeControl.dataNodes = v;\n            this.flattenedData = v;\n        });\n        this.subs.add(subs);\n        return merge(collectionViewer.viewChange, this._flattenedData.asObservable()).pipe(map(() => this.flattenedData));\n    }\n    disconnect(collectionViewer) {\n        this.subs.unsubscribe();\n    }\n}\n\nclass SyncCollectionService {\n    constructor(_config) {\n        this._config = _config;\n        this.config = {\n            name: 'no_name_sync_collection',\n            db$: of(),\n            attachments: {},\n            options: {},\n            migrationStrategies: {},\n            autoMigrate: true,\n            ngZone: null,\n            httpClient: null,\n        };\n        this.config = {\n            ...this.config,\n            ...this._config\n        };\n        this.retryChange = new BehaviorSubject(true);\n        this.storedCollections = this.collection$.pipe(switchMap(col => col.find().$), map(docs => docs.map(d => d.toJSON())), map(docTypes => {\n            const databasesSchema = {};\n            docTypes.forEach(d => {\n                const key = d.databaseOptions;\n                key in databasesSchema ? databasesSchema[key].push(d) : databasesSchema[key] = [d];\n            });\n            const databasesMap = [];\n            Object.keys(databasesSchema).forEach(schema => {\n                const pwaDatabaseService = new PwaDatabaseService({ dbCreator: { ...JSON.parse(schema), ignoreDuplicate: true } });\n                databasesMap.push({ database: pwaDatabaseService.db$, collectionInfo: databasesSchema[schema] });\n            });\n            return databasesMap;\n        }), switchMap(databasesMap => combineLatest(databasesMap.map(m => {\n            return m.database.pipe(switchMap(db => {\n                const collectionInfoKeyValue = m.collectionInfo.reduce((cur, acc) => {\n                    acc[cur.collectionName] = cur;\n                    return acc;\n                }, {});\n                const collections = {};\n                m.collectionInfo.forEach(i => {\n                    const collectionOptions = JSON.parse(i.collectionOptions);\n                    collections[i.collectionName] = getCollectionCreator(i.collectionName, pwaCollectionMethods, pwaDocMethods, collectionOptions.attachments, collectionOptions.options, collectionOptions.migrationStrategies, collectionOptions.autoMigrate);\n                });\n                return from(db.addCollections(collections)).pipe(map(v => Object.keys(v).map(k => ({\n                    collection: v[k],\n                    ...collectionInfoKeyValue[k],\n                }))));\n            }));\n        }))), map(v => flatten(v)), tap((v) => {\n            v.forEach(docType => {\n                docType.collection.preSave((plainData, rxDocument) => {\n                    plainData.createdAt = plainData.createdAt || new Date().getTime();\n                    plainData.updatedAt = new Date().getTime();\n                }, false);\n            });\n        }), shareReplay(1));\n    }\n    get collection$() {\n        if (this._collection$) {\n            return this._collection$;\n        }\n        const collectionSchema = {};\n        collectionSchema[this.config.name] = getSynchroniseCollectionCreator(this.config.name, synchroniseCollectionMethods, synchroniseDocMethods, this.config.attachments, this.config.options, this.config.migrationStrategies, this.config.autoMigrate);\n        this._collection$ = this.config.db$.pipe(switchMap(db => from(db.addCollections(collectionSchema))), map(collections => collections[this.config.name]), shareReplay(1), first());\n        return this._collection$;\n    }\n    addSynchroniseDocument(data) {\n        return this.collection$.pipe(switchMap(col => col.atomicUpsert(data)));\n    }\n    startSync() {\n        this.retryChange.next(true);\n    }\n    stopSync() {\n        this.retryChange.next(false);\n    }\n    unsynchronised(tenant, order = 'asc') {\n        return this.storedCollections.pipe(switchMap((collectionsInfo) => {\n            const query = {\n                selector: {\n                    matchUrl: { $regex: new RegExp(`^${tenant}.*`) },\n                    method: { $ne: 'GET' }\n                }\n            };\n            const sortedDocs$ = collectionsInfo.map(k => {\n                return from(k.collection.find(query).$.pipe(auditTime(1000 / 60)));\n            });\n            return combineLatest(sortedDocs$);\n        }), map(sortedDocs => flatten(sortedDocs)), map((sortedDocs) => sortedDocs.sort((a, b) => order === 'asc' ? a.time - b.time : b.time - a.time)), enterZone(this.config.ngZone));\n    }\n    synchronise(tenant) {\n        const pop = this.unsynchronised(tenant, 'asc').pipe(filter$1(sortedDocs => sortedDocs.length > 0), map(sortedDocs => sortedDocs[0]));\n        const hit = pop.pipe(concatMap(doc => {\n            if (doc.method === 'POST') {\n                const url = doc.tenantUrl.split('____')[1].split('/');\n                url.splice(url.length - 1, 1);\n                let formData;\n                if (doc.fileFields.length) {\n                    formData = createFormData(doc.toJSON().data);\n                    doc.fileFields.forEach(k => {\n                        formData.delete(k.fileField);\n                        formData.delete(k.fileNameField);\n                        formData.delete(k.fileType);\n                        if (k.fileKeyField && k.fileField && k.fileType)\n                            formData.append(k.fileKeyField, new File([new Uint8Array(JSON.parse(doc.data[k.fileField])).buffer], k.fileNameField || 'Unknown', { type: k.fileType }));\n                    });\n                }\n                else {\n                    formData = doc.toJSON().data;\n                }\n                return this.config.httpClient.post(url.join('/'), formData).pipe(switchMap(res => doc.atomicPatch({\n                    method: 'GET',\n                    data: res,\n                    error: null,\n                    time: new Date().getTime()\n                })), catchError(err => {\n                    return from(doc.atomicPatch({ error: JSON.stringify(err) })).pipe(finalize(() => this.retryChange.next(false)));\n                }));\n            }\n            else if (doc.method === 'PUT') {\n                let formData;\n                if (doc.fileFields.length) {\n                    formData = createFormData(doc.toJSON().data);\n                    doc.fileFields.forEach(k => {\n                        formData.delete(k.fileField);\n                        formData.delete(k.fileNameField);\n                        formData.delete(k.fileType);\n                        if (k.fileKeyField && k.fileField && k.fileType)\n                            formData.append(k.fileKeyField, new File([new Uint8Array(JSON.parse(doc.data[k.fileField])).buffer], k.fileNameField || 'Unknown', { type: k.fileType }));\n                    });\n                }\n                else {\n                    formData = doc.toJSON().data;\n                }\n                return this.config.httpClient.put(doc.tenantUrl.split('____')[1], formData).pipe(switchMap(res => doc.atomicPatch({\n                    method: 'GET',\n                    data: res,\n                    error: null,\n                    time: new Date().getTime()\n                })), catchError(err => {\n                    return from(doc.atomicPatch({ error: JSON.stringify(err) })).pipe(finalize(() => this.retryChange.next(false)));\n                }));\n            }\n            else if (doc.method === 'DELETE') {\n                return this.config.httpClient.delete(doc.tenantUrl.split('____')[1]).pipe(switchMap(() => doc.remove()), catchError(err => {\n                    return from(doc.atomicPatch({ error: JSON.stringify(err) })).pipe(finalize(() => this.retryChange.next(false)));\n                }));\n            }\n            return throwError(`Document doesn\\'t have valid method. Document: ${JSON.stringify(doc?.toJSON())}`);\n        }));\n        return this.retryChange.asObservable().pipe(switchMap(trigger => trigger ? hit : of()));\n    }\n    evict() {\n        return this.storedCollections.pipe(switchMap(collectionInfo => {\n            const evicts = collectionInfo.map(k => {\n                const cacheAllowedAge = new Date().getTime() - (k.collectionEvictTime * 1000);\n                return k.collection.insert$.pipe(switchMap(() => k.collection.find({ selector: { $and: [{ method: { $eq: 'GET' } }, { time: { $lt: cacheAllowedAge } }] } }).remove()));\n            });\n            return combineLatest(evicts);\n        }));\n    }\n    skipTrim() {\n        return this.storedCollections.pipe(switchMap((collectionInfo) => {\n            const skipTrims = collectionInfo.map(k => {\n                return k.collection.insert$.pipe(switchMap(() => k.collection.find({ selector: { method: { $eq: 'GET' } }, sort: [{ time: 'desc' }], skip: k.collectionSkipDocuments }).remove()));\n            });\n            return combineLatest(skipTrims);\n        }));\n    }\n    createNew(doc) {\n        if (!!doc && doc.method !== 'GET' && doc.method !== 'POST') {\n            return from(doc.atomicPatch({ method: 'POST' }));\n        }\n        return throwError(`Cannot duplicate this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n    }\n    deleteConflict(doc) {\n        if (!!doc && doc.method !== 'GET') {\n            return from(doc.remove());\n        }\n        return throwError(`Cannot delete this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n    }\n}\nfunction createFormData(object, form, namespace) {\n    let formData = form || new FormData();\n    for (let propertyName in object) {\n        const formKey = namespace ? `${namespace}.${propertyName}` : propertyName;\n        if (object[propertyName] instanceof Date) {\n            formData.append(formKey, object[propertyName].toISOString());\n        }\n        else if (object[propertyName] instanceof Array) {\n            object[propertyName].forEach((element, index) => {\n                const tempFormKey = `${formKey}-${index}`;\n                if (typeof element === 'object') {\n                    createFormData(element, formData, tempFormKey);\n                }\n                else {\n                    formData.append(tempFormKey, element.toString());\n                }\n            });\n        }\n        else if (typeof object[propertyName] === 'object' && !(object[propertyName] instanceof File) && object[propertyName] !== null && object[propertyName] !== undefined) {\n            createFormData(object[propertyName], formData, formKey);\n        }\n        else {\n            formData.append(formKey, object[propertyName] === null || object[propertyName] === undefined ? '' : object[propertyName].toString());\n        }\n    }\n    return formData;\n}\n\naddPouchPlugin(require('pouchdb-adapter-idb'));\nclass SyncDatabaseService {\n    constructor(_config) {\n        this._config = _config;\n    }\n    get db$() {\n        if (this._db$) {\n            return this._db$;\n        }\n        addRxPlugin(RxDBEncryptionPlugin);\n        addRxPlugin(RxDBLeaderElectionPlugin);\n        addRxPlugin(RxDBValidatePlugin);\n        const pouchAdapter = getRxStoragePouch('idb');\n        pouchAdapter.pouchSettings.revs_limit = 0,\n            pouchAdapter.pouchSettings.auto_compaction = true;\n        this._db$ = from(createRxDatabase({\n            name: 'synchronise/pwadb',\n            storage: pouchAdapter,\n            password: 'ubT6LIL7ne2bdpze0V1DaeOGKKqYMWVF',\n            multiInstance: true,\n            eventReduce: true,\n            ...this._config.dbCreator\n        })).pipe(switchMap((db) => from(db.waitForLeadership()).pipe(startWith(null), map(() => db))), shareReplay(1), first());\n        return this._db$;\n    }\n}\n\nexport { ApiProgressService, BaseDatabase, CollectionAPI, CustomEncoder, CustomHttpParams, Database, DynamicFlatNode, DynamicFlatTreeDataSource, DynamicTreeFlattener, PwaCollectionAPI, PwaDatabaseService, ReactiveDatabase, RestAPI, SyncCollectionService, SyncDatabaseService, TreeDatabase, contains, createFormData, distinct, endswith, enterZone, eq, exact, exclude, filter, flatten, getCollectionCreator, getQuery, getSchema, getSynchroniseCollectionCreator, getSynchroniseSchema, gt, gte, icontains, iexact, isnull, lt, lte, orderBy, parseBoolean, parseDate, parseNumber, pwaCollectionMethods, pwaDocMethods, queryFilter, range, startswith, synchroniseCollectionMethods, synchroniseDocMethods };\n//# sourceMappingURL=advance-tools-pwadb-lib.mjs.map\n","map":{"version":3,"file":"advance-tools-pwadb-lib.mjs","sources":["../../../projects/pwadb-lib/src/lib/definitions/document.ts","../../../projects/pwadb-lib/src/lib/definitions/collection.ts","../../../projects/pwadb-lib/src/lib/definitions/synchronise-document.ts","../../../projects/pwadb-lib/src/lib/definitions/synchronise-collection.ts","../../../projects/pwadb-lib/src/lib/resources/customParams.resource.ts","../../../projects/pwadb-lib/src/lib/resources/filters.resource.ts","../../../projects/pwadb-lib/src/lib/resources/operators.resource.ts","../../../projects/pwadb-lib/src/lib/resources/collection.resource.ts","../../../projects/pwadb-lib/src/lib/resources/database.resource.ts","../../../projects/pwadb-lib/src/lib/resources/apiProgress.resource.ts","../../../projects/pwadb-lib/src/lib/resources/misc.resource.ts","../../../projects/pwadb-lib/src/lib/resources/table.resource.ts","../../../projects/pwadb-lib/src/lib/resources/tree.resource.ts","../../../projects/pwadb-lib/src/lib/resources/synchronise-collection.resource.ts","../../../projects/pwadb-lib/src/lib/resources/synchronise-database.resource.ts"],"sourcesContent":["import { RxJsonSchema, RxDocument } from 'rxdb';\n\nexport type Method = 'GET' | 'POST' | 'PUT' | 'DELETE';\n\nexport type Datatype = {\n    id: string;\n};\n\nexport interface FileConfig {\n    fileField: string;\n    fileNameField: string;\n    fileType: string;\n    fileKeyField: string;\n}\n\nexport type PwaDocType<T extends Datatype> = {\n    tenantUrl: string;\n    matchUrl: string;\n    method: Method;\n    data: T | null;\n    time: number;\n    error: string | null;\n    fileFields: FileConfig[];\n    createdAt: number;\n    updatedAt: number;\n};\n\nexport type PwaDocMethods = {};\n\nexport type PwaDocument<T extends Datatype> = RxDocument<PwaDocType<T>, PwaDocMethods>;\n\nexport const getSchema: (name: string) => RxJsonSchema<PwaDocType<any>> = (name: string) => ({\n    title: name + '_store',\n    description: `Store ${name} types of data in the collection`,\n    keyCompression: false,\n    version: 4,\n    type: 'object',\n    primaryKey: 'tenantUrl',\n    properties: {\n        tenantUrl: {\n            type: 'string',\n            primary: true,\n        },\n        matchUrl: {\n            type: 'string',\n        },\n        method: {\n            type: 'string',\n            enum: ['GET', 'POST', 'PUT', 'DELETE'],\n        },\n        data: {\n            type: ['object', 'null'],\n        },\n        time: {\n            type: 'integer',\n        },\n        error: {\n            type: ['string', 'null'],\n        },\n        fileFields: {\n            type: ['array'],\n            default: [],\n            items: {\n                type: ['object'],\n                properties: {\n                    fileField: {\n                        type: ['string']\n                    },\n                    fileNameField: {\n                        type: ['string']\n                    },\n                    fileType: {\n                        type: ['string']\n                    },\n                    fileKeyField: {\n                        type: ['string']\n                    }\n                }\n            }\n        },\n        createdAt: {\n            type: 'integer',\n        },\n        updatedAt: {\n            type: 'integer'\n        }\n    },\n    encrypted: [\n        'data',\n        'fileFields'\n    ],\n});\n\nexport const pwaDocMethods: PwaDocMethods = {};\n","import { PwaDocType, PwaDocMethods, Datatype, getSchema, PwaDocument } from './document';\nimport { RxCollection, RxCollectionCreator } from 'rxdb';\n\nexport type PwaCollectionMethods = {};\n\nexport type PwaCollection<T extends Datatype> = RxCollection<PwaDocType<T>, PwaDocMethods, PwaCollectionMethods>;\n\nexport const getCollectionCreator = (\n    name: string,\n    collectionMethods: PwaCollectionMethods,\n    documentMethods: PwaDocMethods,\n    attachments = {},\n    options = {},\n    migrationStrategies = {},\n    autoMigrate = true,\n) => ({\n        name,\n        schema: getSchema(name),\n        statics: collectionMethods, // (optional) // ORM-functions for this collection\n        methods: documentMethods, // (optional) ORM-functions for documents\n        attachments, // (optional) ORM-functions for attachments\n        options, // (optional) Custom paramters that might be used in plugins\n        migrationStrategies: {\n            // 1 means, this transforms data from version 0 to version 1\n            1: (oldDoc: PwaDocType<any>) => {\n\n                oldDoc.createdAt = new Date().getTime();\n                oldDoc.updatedAt = new Date().getTime();\n\n                return oldDoc;\n            },\n            2: (oldDoc: PwaDocType<any>) => {\n\n                oldDoc.fileFields = [];\n\n                return oldDoc;\n            },\n            3: (oldDoc: PwaDocType<any>) => {\n\n                oldDoc.fileFields = [];\n\n                return oldDoc;\n            },\n            4: (oldDoc: PwaDocType<any>) => {\n\n                oldDoc.fileFields = [];\n\n                return oldDoc;\n            },\n            ...migrationStrategies\n        }, // (optional)\n        autoMigrate, // (optional)\n} as RxCollectionCreator);\n\nexport const pwaCollectionMethods: PwaCollectionMethods = {};\n\n///////////////////////\n// interfaces\n///////////////////////\n\nexport interface ListResponse<T extends Datatype> {\n    next: string;\n    previous: string;\n    results: T[];\n}\n\nexport interface CollectionListResponse<T extends Datatype> {\n    next: string;\n    previous: string;\n    results: PwaDocument<T>[];\n    count?: number;\n}\n\nexport interface PwaListResponse<T extends Datatype> {\n    next: string;\n    previous: string;\n    results: PwaDocument<T>[];\n}\n","import { RxDocument, RxJsonSchema } from 'rxdb';\nimport { PwaDocument } from './document';\n\nexport type SynchroniseDocType = {\n    id: string;\n    databaseOptions: string,\n    collectionName: string,\n    collectionOptions: string,\n    collectionEvictTime: number,\n    collectionSkipDocuments: number\n};\n\nexport type SynchroniseDocMethods = {};\n\nexport type SynchroniseDocument = RxDocument<SynchroniseDocType>;\n\nexport const getSynchroniseSchema: () => RxJsonSchema<SynchroniseDocType> = () => ({\n    title: 'synchronise_store',\n    description: `Stores database & collectionNames of data in the collection`,\n    keyCompression: false,\n    version: 0,\n    type: 'object',\n    primaryKey: 'id',\n    properties: {\n        id: {\n            type: 'string',\n            primary: true,\n        },\n        databaseOptions: {\n            type: 'string',\n        },\n        collectionName: {\n            type: 'string'\n        },\n        collectionOptions: {\n            type: 'string',\n        },\n        collectionEvictTime: {\n            type: 'integer'\n        },\n        collectionSkipDocuments: {\n            type: 'integer'\n        },\n        collectionReqTitleFieldName: {\n            type: 'string'\n        },\n        collectionReqSubTitleFieldName: {\n            type: ['string', 'null']\n        },\n        collectionReqIconFieldName: {\n            type: ['string', 'null']\n        }\n    },\n    encrypted: [\n        'databaseOptions',\n        'collectionName',\n        'collectionOptions',\n        'collectionEvictTime',\n        'collectionSkipDocuments',\n        'collectionReqTitleFieldName',\n        'collectionReqSubTitleFieldName',\n        'collectionReqIconFieldName',\n    ],\n});\n\nexport const synchroniseDocMethods: SynchroniseDocMethods = {};\n\n","import { RxCollection, RxCollectionCreator } from 'rxdb';\nimport { getSynchroniseSchema, SynchroniseDocMethods, SynchroniseDocType } from './synchronise-document';\n\nexport type SynchroniseCollectionMethods = {};\n\nexport type SynchroniseCollection = RxCollection<SynchroniseDocType, SynchroniseDocMethods, SynchroniseCollectionMethods>;\n\nexport const getSynchroniseCollectionCreator = (\n    name: string,\n    collectionMethods: SynchroniseCollectionMethods,\n    documentMethods: SynchroniseDocMethods,\n    attachments = {},\n    options = {},\n    migrationStrategies = {},\n    autoMigrate = true,\n) => ({\n        name,\n        schema: getSynchroniseSchema(),\n        pouchSettings: {\n            revs_limit: 0,\n            auto_compaction: true,\n        }, // (optional)\n        statics: collectionMethods, // (optional) // ORM-functions for this collection\n        methods: documentMethods, // (optional) ORM-functions for documents\n        attachments, // (optional) ORM-functions for attachments\n        options, // (optional) Custom paramters that might be used in plugins\n        migrationStrategies, // (optional)\n        autoMigrate, // (optional)\n} as RxCollectionCreator);\n\nexport const synchroniseCollectionMethods: SynchroniseCollectionMethods = {};\n","import { HttpParameterCodec, HttpParams, HttpParamsOptions } from \"@angular/common/http\";\n\nexport class CustomEncoder implements HttpParameterCodec {\n    encodeKey(key: string): string {\n        return encodeURIComponent(key);\n    }\n\n    encodeValue(value: string): string {\n        return encodeURIComponent(value);\n    }\n\n    decodeKey(key: string): string {\n        return decodeURIComponent(key);\n    }\n\n    decodeValue(value: string): string {\n        return decodeURIComponent(value);\n    }\n}\n\nexport class CustomHttpParams extends HttpParams {\n\n    constructor(options?: HttpParamsOptions) {\n\n        options = {...(options || {}), encoder: new CustomEncoder()};\n\n        super(options)\n    }\n}\n","import { PwaDocument } from '../definitions/document';\nimport { HttpParams } from '@angular/common/http';\n\n////////////////\n// Types\n////////////////\n// tslint:disable-next-line: max-line-length\nexport type Lookup = 'gte' | 'lte' | 'gt' | 'lt' | 'eq' | 'startswith' | 'endswith' | 'range' | 'isnull' | 'iexact' | 'exact' | 'icontains' | 'contains' | 'in';\n\nexport type Query = 'filter' | 'distinct' | 'exclude' | 'ordering' | 'only';\n\nexport type FieldDataType = string | number | boolean | null;\n\n////////////////\n// Parsers\n////////////////\nexport function parseNumber(fieldValue: FieldDataType, inputValue: string): null | {[key: string]: number} {\n\n    const parsedFieldValue = Number(fieldValue?.toString() || '');\n\n    const parsedInputValue = Number(inputValue?.toString() || '');\n\n    return isNaN(parsedFieldValue) && isNaN(parsedInputValue) ? null : {parsedFieldValue, parsedInputValue};\n}\n\nexport function parseDate(fieldValue: FieldDataType, inputValue: string): null | {[key: string]: number} {\n\n    const parsedFieldValue = Date.parse(fieldValue?.toString() || '');\n\n    const parsedInputValue = Date.parse(inputValue?.toString() || '');\n\n    return isNaN(parsedFieldValue) && isNaN(parsedInputValue) ? null : {parsedFieldValue, parsedInputValue};\n}\n\nexport function parseBoolean(fieldValue: FieldDataType, inputValue: string): null | {[key: string]: boolean} {\n\n    // tslint:disable-next-line: max-line-length\n    const parsedFieldValue = fieldValue?.toString().toLowerCase() === 'true' ? true : fieldValue?.toString().toLowerCase() === 'false' ? false : null;\n\n    // tslint:disable-next-line: max-line-length\n    const parsedInputValue = inputValue?.toString().toLowerCase() === 'true' ? true : inputValue?.toString().toLowerCase() === 'false' ? false : null;\n\n    return parsedFieldValue === null || parsedInputValue === null ? null : {parsedFieldValue, parsedInputValue};\n}\n\n///////////////////////////////////////////////\n// Lookup Filters (num, date, string, boolean)\n///////////////////////////////////////////////\n\n// tslint:disable-next-line: max-line-length\nexport const eq: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue === isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue === isNumber.parsedInputValue; }\n\n    const isBoolean = parseBoolean(v.data[field] as FieldDataType, inputValue);\n\n    if (isBoolean) { return isBoolean.parsedFieldValue === isBoolean.parsedInputValue; }\n\n    return v.data[field] === inputValue;\n};\n\n///////////////////////////////////////////////\n// Lookup Filters (num, date)\n///////////////////////////////////////////////\n\n// tslint:disable-next-line: max-line-length\nexport const gte: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue >= isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue >= isNumber.parsedInputValue; }\n\n    return v.data[field] >= inputValue;\n};\n\n// tslint:disable-next-line: max-line-length\nexport const lte: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue <= isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue <= isNumber.parsedInputValue; }\n\n    return v.data[field] <= inputValue;\n};\n\n// tslint:disable-next-line: max-line-length\nexport const gt: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue > isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue > isNumber.parsedInputValue; }\n\n    return v.data[field] > inputValue;\n};\n\n// tslint:disable-next-line: max-line-length\nexport const lt: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue < isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue < isNumber.parsedInputValue; }\n\n    return v.data[field] < inputValue;\n};\n\n// tslint:disable-next-line: max-line-length\nexport const range: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const values = inputValue.toString().split(',');\n\n    const isDate1 = parseDate(v.data[field] as FieldDataType, values[0]);\n\n    const isDate2 = parseDate(v.data[field] as FieldDataType, values[1]);\n\n    // tslint:disable-next-line: max-line-length\n    if (isDate1 && isDate2) { return isDate1.parsedFieldValue >= isDate1.parsedInputValue && isDate2.parsedFieldValue < isDate2.parsedInputValue; }\n\n    const isNumber1 = parseNumber(v.data[field] as FieldDataType, values[0]);\n\n    const isNumber2 = parseNumber(v.data[field] as FieldDataType, values[1]);\n\n    // tslint:disable-next-line: max-line-length\n    if (isNumber1 && isNumber2) { return isNumber1.parsedFieldValue >= isNumber1.parsedInputValue && isNumber2.parsedFieldValue < isNumber2.parsedInputValue; }\n\n    return v.data[field] >= values[0] && v.data[field] < values[1];\n};\n\n///////////////////////////////////////////////\n// Lookup Filters (string)\n///////////////////////////////////////////////\n\n// tslint:disable-next-line: max-line-length\nexport const startswith: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => (v.data[field] as FieldDataType)?.toString().startsWith(inputValue);\n\n// tslint:disable-next-line: max-line-length\nexport const endswith: (v: PwaDocument<any>, field: string, inputValue: string) => boolean   = (v: PwaDocument<any>, field: string, inputValue: string) => (v.data[field] as FieldDataType)?.toString().endsWith(inputValue);\n\n// tslint:disable-next-line: max-line-length\nexport const iexact: (v: PwaDocument<any>, field: string, inputValue: string) => boolean     = (v: PwaDocument<any>, field: string, inputValue: string) => !!(v.data[field] as FieldDataType)?.toString().match(new RegExp(`^${inputValue}$`, 'i'));\n\n// tslint:disable-next-line: max-line-length\nexport const exact: (v: PwaDocument<any>, field: string, inputValue: string) => boolean      = (v: PwaDocument<any>, field: string, inputValue: string) => !!(v.data[field] as FieldDataType)?.toString().match(new RegExp(`^${inputValue}$`));\n\n// tslint:disable-next-line: max-line-length\nexport const icontains: (v: PwaDocument<any>, field: string, inputValue: string) => boolean  = (v: PwaDocument<any>, field: string, inputValue: string) => (v.data[field] as FieldDataType)?.toString().toLowerCase().includes(inputValue?.toLowerCase() || '');\n\n// tslint:disable-next-line: max-line-length\nexport const contains: (v: PwaDocument<any>, field: string, inputValue: string) => boolean   = (v: PwaDocument<any>, field: string, inputValue: string) => (v.data[field] as FieldDataType)?.toString().includes(inputValue);\n\n///////////////////////////////////////////////\n// Lookup Filters (boolean)\n///////////////////////////////////////////////\n// tslint:disable-next-line: max-line-length\nexport const isnull: (v: PwaDocument<any>, field: string, inputValue: string) => boolean     = (v: PwaDocument<any>, field: string, inputValue: string) => inputValue?.toLowerCase() === 'true' ? v.data[field] === null : v.data[field] !== null;\n\n\nexport function getQuery(key: string, value: string): {queryType: Query, fields: string[], lookup?: Lookup, inputValue?: string} {\n\n    if (key.includes('distinct')) {\n\n        return {queryType: 'distinct', fields: value.split(',')};\n\n    } else if (key.includes('only')) {\n\n        return {queryType: 'only', fields: value.split(',')};\n\n    } else if (key.includes('ordering')) {\n\n        return {queryType: 'ordering', fields: value.split(',')};\n\n    } else if (key.includes('exclude')) {\n\n        const fieldAndLookup = key.split(':')[1].split('.');\n\n        // tslint:disable-next-line: max-line-length\n        return {queryType: 'exclude', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] as Lookup : 'eq', inputValue: value};\n\n    } else if (key.includes('filter')) {\n\n        const fieldAndLookup = key.split(':')[1].split('.');\n\n        // tslint:disable-next-line: max-line-length\n        return {queryType: 'filter', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] as Lookup : 'eq', inputValue: value};\n\n    } else {\n\n        const fieldAndLookup = key.split('.');\n\n        // tslint:disable-next-line: max-line-length\n        return {queryType: 'filter', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] as Lookup : 'eq', inputValue: value};\n    }\n\n}\n\n\nexport function queryFilter(validQueryKeys: string[], params: HttpParams, docs: PwaDocument<any>[]): PwaDocument<any>[] {\n\n    if (params) {\n\n        const keys = params.keys();\n\n        //////////////\n        // Filters (1)\n        //////////////\n        keys.forEach(k => {\n\n            if (validQueryKeys.indexOf(k) > -1) {\n\n                const query = getQuery(k, params.getAll(k).join(','));\n\n                if (query.queryType === 'filter') { docs = filter(query.fields[0], query.inputValue, docs, query.lookup); }\n            }\n        });\n\n        ///////////////\n        // Exclude (2)\n        ///////////////\n\n        keys.forEach(k => {\n\n            if (validQueryKeys.indexOf(k) > -1) {\n\n                const query = getQuery(k, params.getAll(k).join(','));\n\n                if (query.queryType === 'exclude') { docs = exclude(query.fields[0], query.inputValue, docs, query.lookup); }\n            }\n        });\n\n        ////////////////\n        // Order By (3)\n        ////////////////\n\n        keys.forEach(k => {\n\n            if (validQueryKeys.indexOf(k) > -1) {\n\n                const query = getQuery(k, params.getAll(k).join(','));\n\n                if (query.queryType === 'ordering') { docs = orderBy(query.fields, docs); }\n            }\n        });\n\n        ////////////////\n        // Distinct (4)\n        ////////////////\n\n        keys.forEach(k => {\n\n            if (validQueryKeys.indexOf(k) > -1) {\n\n                const query = getQuery(k, params.getAll(k).join(','));\n\n                if (query.queryType === 'distinct') { docs = distinct(query.fields, docs); }\n            }\n        });\n\n    }\n\n    return docs;\n}\n\nexport function filter(field: string, inputValue: string, docs: PwaDocument<any>[], lookup?: Lookup, isExclude = false): PwaDocument<any>[] {\n\n    // in lookup would same as eq with OR values\n    let f = (v: PwaDocument<any>) => inputValue.split(',').reduce((acc, cur) => acc || eq(v, field, cur), false);\n\n    if (lookup === 'gte') { f = v => inputValue.split(',').reduce((acc, cur) => acc || gte(v, field, cur), false); }\n\n    if (lookup === 'lte') { f = v => inputValue.split(',').reduce((acc, cur) => acc || lte(v, field, cur), false); }\n\n    if (lookup === 'gt') { f = v => inputValue.split(',').reduce((acc, cur) => acc || gt(v, field, cur), false); }\n\n    if (lookup === 'lt') { f = v => inputValue.split(',').reduce((acc, cur) => acc || lt(v, field, cur), false); }\n\n    if (lookup === 'range') { f = v => range(v, field, inputValue); }\n\n    if (lookup === 'startswith') { f = v => inputValue.split(',').reduce((acc, cur) => acc || startswith(v, field, cur), false); }\n\n    if (lookup === 'endswith') { f = v => inputValue.split(',').reduce((acc, cur) => acc || endswith(v, field, cur), false); }\n\n    if (lookup === 'iexact') { f = v => inputValue.split(',').reduce((acc, cur) => acc || iexact(v, field, cur), false); }\n\n    if (lookup === 'exact') { f = v => inputValue.split(',').reduce((acc, cur) => acc || exact(v, field, cur), false); }\n\n    if (lookup === 'icontains') { f = v => inputValue.split(',').reduce((acc, cur) => acc || icontains(v, field, cur), false); }\n\n    if (lookup === 'contains') { f = v => inputValue.split(',').reduce((acc, cur) => acc || contains(v, field, cur), false); }\n\n    if (lookup === 'isnull') { f = v => inputValue.split(',').reduce((acc, cur) => acc || isnull(v, field, cur), false); }\n\n    return docs.filter((v) => {\n\n        const o = f(v);\n\n        return isExclude ? !o : o;\n    });\n}\n\nexport function exclude(field: string, inputValue: string, docs: PwaDocument<any>[], lookup?: Lookup): PwaDocument<any>[] {\n\n    return filter(field, inputValue, docs, lookup, true);\n}\n\nexport function distinct(fields: string[], docs: PwaDocument<any>[]): PwaDocument<any>[] {\n\n    const uniques = new Set<FieldDataType>();\n\n    const distinctArray: PwaDocument<any>[] = [];\n\n    docs.forEach(v => {\n\n        const key = fields.reduce((acc, cur) => acc += `-${(v.data[cur] as FieldDataType)?.toString() || 'null'}`, '');\n\n        if (!uniques.has(key)) {\n\n            uniques.add(key);\n\n            distinctArray.push(v);\n        }\n    });\n\n    return distinctArray;\n}\n\nexport function orderBy(fields: string[], docs: PwaDocument<any>[]): PwaDocument<any>[] {\n\n    return docs.sort((a, b) => {\n\n        // tslint:disable-next-line: prefer-for-of\n        for (let i = 0; i < fields.length; i++) {\n\n            const order = fields[i].indexOf('-') === 0 ? 'desc' : 'asc';\n\n            const parseFieldName = order === 'desc' ? fields[i].split('-')[1] : fields[i];\n\n            if (!(parseFieldName in a?.data) || !(parseFieldName in b?.data)) { continue; }\n\n            let output = 0;\n\n            const isDate = parseDate(a.data[parseFieldName], b.data[parseFieldName]);\n\n            // tslint:disable-next-line: max-line-length\n            if (isDate && order === 'asc' && isDate.parsedFieldValue !== isDate.parsedInputValue) { \n\n                output = isDate.parsedFieldValue - isDate.parsedInputValue;\n\n                if (output > 0 || output < 0) { return output; }\n            }\n\n            // tslint:disable-next-line: max-line-length\n            if (isDate && order === 'desc' && isDate.parsedInputValue !== isDate.parsedFieldValue) { \n\n                output = isDate.parsedInputValue - isDate.parsedFieldValue;\n\n                if (output > 0 || output < 0) { return output; }\n            }\n\n            const isNumber = parseNumber(a.data[parseFieldName], b.data[parseFieldName]);\n\n            // tslint:disable-next-line: max-line-length\n            if (isNumber && order === 'asc' && isNumber.parsedFieldValue !== isNumber.parsedInputValue) {\n\n                output = isNumber.parsedFieldValue - isNumber.parsedInputValue;\n\n                if (output > 0 || output < 0) { return output; }\n            }\n\n            // tslint:disable-next-line: max-line-length\n            if (isNumber && order === 'desc' && isNumber.parsedInputValue !== isNumber.parsedFieldValue) {\n\n                output = isNumber.parsedInputValue - isNumber.parsedFieldValue;\n\n                if (output > 0 || output < 0) { return output; }\n            }\n\n            const valueA = (a.data[parseFieldName] as FieldDataType)?.toString() || '';\n\n            const valueB = (b.data[parseFieldName] as FieldDataType)?.toString() || '';\n\n            output = order === 'asc' ? valueA.localeCompare(valueB) : valueA.localeCompare(valueB) * -1;\n\n            if (output > 0 || output < 0) { return output; }\n\n        }\n\n        return 0;\n    });\n}\n","import { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n\nexport function enterZone<T>(zone: NgZone) {\n\n    return (source: Observable<T>) =>\n\n        new Observable<T>(observer =>\n\n            source.subscribe({\n                next: (x) => zone.run(() => observer.next(x)),\n                error: (err) => observer.error(err),\n                complete: () => observer.complete()\n            })\n        );\n}\n","import { Datatype, FileConfig, getSchema, pwaDocMethods, PwaDocType, PwaDocument } from '../definitions/document';\nimport { getCollectionCreator, PwaCollection, pwaCollectionMethods, ListResponse, PwaListResponse, CollectionListResponse } from '../definitions/collection';\nimport { switchMap, map, catchError, shareReplay, tap, finalize, startWith, take, auditTime, timeout } from 'rxjs/operators';\nimport { Observable, of, from, throwError, combineLatest } from 'rxjs';\nimport { HttpClient, HttpParams } from '@angular/common/http';\nimport { queryFilter } from './filters.resource';\nimport { RxCollectionCreator, RxDatabase } from 'rxdb';\nimport { NgZone } from '@angular/core';\nimport { enterZone } from './operators.resource';\nimport { ApiProgressService } from './apiProgress.resource';\nimport { SyncCollectionService } from './synchronise-collection.resource';\nimport { SynchroniseDocType } from '../definitions/synchronise-document';\nimport { CustomHttpParams } from './customParams.resource';\n\n\nexport interface RestAPICreator {\n    apiProgress?: ApiProgressService;\n    httpClient?: HttpClient;\n}\n\n\nexport interface CollectionAPICreator<Database> {\n    name?: string;\n    db$?: Observable<RxDatabase<Database>>;\n    collectionEvictTime$: Observable<number>;\n    collectionSkipDocuments$: Observable<number>;\n    synchroniseService?: SyncCollectionService;\n    attachments?: {};\n    options?: {};\n    migrationStrategies?: {};\n    autoMigrate?: boolean;\n    ngZone: NgZone;\n}\n\n\nexport interface PwaCollectionAPICreator<Database> {\n    collectionApiCreator: Partial<CollectionAPICreator<Database>>;\n    restApiCreator: Partial<RestAPICreator>;\n    cacheTimeInSeconds: number;\n}\n\n\nexport class RestAPI<T extends Datatype> {\n\n    private cache: Map<string, Observable<T> | Observable<ListResponse<T>>> = new Map();\n\n    constructor(private config: RestAPICreator) {}\n\n    ////////////////\n    // CRUD\n    ////////////////\n\n    get(url: string, params?: HttpParams): Observable<T> {\n\n        const paramsUrl = params?.keys().map(k => `${k}=${params.getAll(k).join(',')}`).join('&');\n\n        const cacheKey = `${url}${paramsUrl ? '?' + paramsUrl : ''}`;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.get(cacheKey)),\n\n            timeout(7500),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n\n            }),\n\n            shareReplay(1),\n\n        ) as Observable<T>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey) as Observable<T>;\n    }\n\n    post(url: string, data: Partial<T> | FormData): Observable<T> {\n\n        const cacheKey = url;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.post(url, data)),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n            }),\n\n            shareReplay(1),\n\n        )  as Observable<T>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey) as Observable<T>;\n    }\n\n    put(url: string, data: Partial<T> | FormData): Observable<T> {\n\n        const cacheKey = url;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.put(url, data)),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n            }),\n\n            shareReplay(1),\n\n        ) as Observable<T>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey) as Observable<T>;\n    }\n\n    list(url: string, params?: HttpParams): Observable<ListResponse<T>> {\n\n        const paramsUrl = params?.keys().map(k => `${k}=${params.getAll(k).join(',')}`).join('&');\n\n        const cacheKey = `${url}${paramsUrl ? '?' + paramsUrl : ''}`;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.get(cacheKey)),\n\n            timeout(7500),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n            }),\n\n            shareReplay(1),\n\n        ) as Observable<ListResponse<T>>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey) as Observable<ListResponse<T>>;\n    }\n\n    delete(url: string): Observable<any> {\n\n        const cacheKey = url;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.delete(url)),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n            }),\n\n            shareReplay(1),\n\n        ) as Observable<any>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey);\n    }\n}\n\n\nexport class CollectionAPI<T extends Datatype, Database> {\n\n    private config: CollectionAPICreator<Database> = {\n        name: 'no_name_collection_api',\n        db$: of(),\n        collectionEvictTime$: of(86400),\n        collectionSkipDocuments$: of(500),\n        attachments: {},\n        options: {},\n        migrationStrategies: {},\n        autoMigrate: true,\n        ngZone: null\n    };\n\n    // tslint:disable-next-line: variable-name\n    private _collection$: Observable<PwaCollection<T>>;\n\n    private cache = new Map();\n\n    constructor(private _config: Partial<CollectionAPICreator<Database>>) {\n\n        this.config = {\n            ...this.config,\n            ...this._config\n        };\n    }\n\n    get collection$(): Observable<PwaCollection<T>> {\n\n        if (this._collection$) { return this._collection$; }\n\n        const collectionSchema = {};\n\n        collectionSchema[this.config.name] = getCollectionCreator(\n            this.config.name,\n            pwaCollectionMethods,\n            pwaDocMethods,\n            this.config.attachments,\n            this.config.options,\n            this.config.migrationStrategies,\n            this.config.autoMigrate\n        );\n\n        this._collection$ = this.config.db$.pipe(\n\n            switchMap(db => {\n\n                if (this.config.name in db) { return of(db[this.config.name]); }\n\n                return combineLatest([\n                    from(db.addCollections(collectionSchema as { [key: string]: RxCollectionCreator; })),\n                    this.config.collectionEvictTime$,\n                    this.config.collectionSkipDocuments$\n                ]).pipe(\n\n                    take(1),\n\n                    switchMap(([collections, collectionEvictTime, collectionSkipDocuments]) => {\n\n                        if (this.config.synchroniseService) {\n\n                            const data: SynchroniseDocType = {\n                                id: db.name + '-' + this.config.name,\n                                databaseOptions: JSON.stringify({\n                                    name: db.name,\n                                    eventReduce: db.eventReduce,\n                                    multiInstance: db.multiInstance,\n                                    options: db.options,\n                                    password: db.password,\n                                }),\n                                collectionEvictTime,\n                                collectionSkipDocuments,\n                                collectionName: this.config.name,\n                                collectionOptions: JSON.stringify({\n                                    name: this.config.name,\n                                    schema: getSchema(this.config.name),\n                                    attachments: collections[this.config.name].attachments,\n                                    autoMigrate: true,\n                                    cacheReplacementPolicy: collections[this.config.name].cacheReplacementPolicy,\n                                    methods: collections[this.config.name].methods,\n                                    migrationStrategies: collections[this.config.name].migrationStrategies,\n                                    options: collections[this.config.name].options,\n                                    statics: collections[this.config.name].statics,\n                                })\n                            };\n\n                            // add collection to synchronise collection service\n                            return this.config.synchroniseService.addSynchroniseDocument(data).pipe(\n\n                                map(() => collections[this.config.name] as PwaCollection<T>)\n                            );\n\n                        } else {\n\n                            return of(collections).pipe(\n\n                                map(() => collections[this.config.name] as PwaCollection<T>)\n                            );\n                        }\n\n                    })\n                );\n            }),\n\n            tap(col => col.preSave((plainData, rxDocument) => {\n\n                // modify anyField before saving\n                // add hook in synchronise-collection as well\n                plainData.createdAt = plainData.createdAt || new Date().getTime();\n                plainData.updatedAt = new Date().getTime();\n\n            }, false)),\n\n            shareReplay(1),\n\n            take(1),\n        );\n\n        return this._collection$;\n    }\n\n    makeTenantUrl(tenant: string, url: string): string {\n\n        return `${tenant}____${url}`;\n    }\n\n    filterDocs(\n        docs: Observable<PwaDocument<T>[]>,\n        url: string,\n        params?: HttpParams,\n        validQueryKeys = []\n    ): Observable<CollectionListResponse<T>> {\n\n        return docs.pipe(\n\n            // map(v => v.sort((a, b) => b.time - a.time)),\n\n            map(allDocs => queryFilter(validQueryKeys, params, allDocs)),\n\n            map(allDocs => {\n\n                // tslint:disable-next-line: radix\n                const start = parseInt(params?.get('offset') || '0');\n\n                // tslint:disable-next-line: radix\n                const end = start + parseInt(params?.get('limit') || '100');\n\n                const next = allDocs.length - end > 0 ? `${url}?${params.set('offset', end.toString()).toString()}` : null;\n\n                const previous = start > 0 ? `${url}?${params.set('offset', start.toString()).toString()}` : null;\n\n                return {next, previous, results: allDocs.slice(start, end), count: allDocs.length};\n            }),\n\n        );\n    }\n\n    ////////////////\n    // CRUD\n    ////////////////\n\n    getReactive(tenant: string, url: string): Observable<PwaDocument<T>> {\n\n        const cacheKey = tenant + url;\n\n        if (!this.cache.has(cacheKey)) {\n\n            const doc = this.collection$.pipe(\n\n                switchMap(col => col.findOne({selector: { tenantUrl: {$eq: this.makeTenantUrl(tenant, url)}}}).$),\n\n                shareReplay(1),\n\n                enterZone<PwaDocument<T>>(this.config.ngZone),\n            );\n\n            this.cache.set(cacheKey, doc);\n        }\n\n        return this.cache.get(cacheKey);\n\n    }\n\n    get(tenant: string, url: string): Observable<PwaDocument<T>> {\n\n        return this.getReactive(tenant, url).pipe(\n\n            take(1),\n        );\n    }\n\n    listReactive(tenant: string, url: string, params?: HttpParams, validQueryKeys = []): Observable<CollectionListResponse<T>> {\n\n        const cacheKey = tenant + url;\n\n        if (!this.cache.has(cacheKey)) {\n\n            const docs = this.collection$.pipe(\n\n                switchMap(col => col.find({ selector: {matchUrl: {$regex: new RegExp(`^${this.makeTenantUrl(tenant, url)}.*`)}} }).$),\n\n                shareReplay(1),\n            );\n\n            this.cache.set(cacheKey, docs);\n        }\n\n        return this.filterDocs(this.cache.get(cacheKey), url, params, validQueryKeys).pipe(\n\n            enterZone<CollectionListResponse<T>>(this.config.ngZone),\n        );\n    }\n\n    list(tenant: string, url: string, params?: HttpParams, validQueryKeys = []): Observable<CollectionListResponse<T>> {\n\n        return this.listReactive(tenant, url, params, validQueryKeys).pipe(\n\n            take(1)\n        );\n    }\n\n    /////////////\n    // Actions\n    /////////////\n\n    post(tenant: string, url: string, data: T, fileFields: FileConfig[] = []): Observable<PwaDocument<T>> {\n\n        return this.collection$.pipe(\n\n            switchMap(col => col.atomicUpsert({\n                tenantUrl: `${this.makeTenantUrl(tenant, url)}/${data.id}`,\n                matchUrl: `${this.makeTenantUrl(tenant, url)}/${data.id}`,\n                method: 'POST',\n                data,\n                error: null,\n                time: new Date().getTime(),\n                fileFields\n            })),\n        );\n    }\n\n    put(tenant: string, url: string, data: T, fileFields: FileConfig[] = []): Observable<PwaDocument<T>> {\n\n        return combineLatest([this.get(tenant, url), this.collection$]).pipe(\n\n            switchMap(([doc, col]) => {\n\n                if (doc) {\n\n                    return doc.atomicPatch({\n                        method: doc.method !== 'POST' ? 'PUT' : doc.method,\n                        data,\n                        error: null,\n                        time: doc.method === 'GET' ? new Date().getTime() : doc.time,\n                        fileFields\n                    });\n\n                } else {\n\n                    const docData: Partial<PwaDocType<T>> = {\n                        tenantUrl: this.makeTenantUrl(tenant, url),\n                        matchUrl: this.makeTenantUrl(tenant, url),\n                        data,\n                        method: 'PUT',\n                        error: null,\n                        time: new Date().getTime(),\n                        fileFields\n                    };\n\n                    return col.atomicUpsert(docData);\n                }\n\n            }),\n        );\n    }\n\n    delete(tenant: string, url: string, data?: T, fileFields: FileConfig[] = []): Observable<boolean | PwaDocument<T>> {\n\n        return this.get(tenant, url).pipe(\n\n            switchMap(doc => {\n\n                if (doc && doc.method === 'POST') {\n\n                    return from(doc.remove());\n\n                } else if (doc && (doc.method === 'PUT' || doc.method === 'DELETE')) {\n\n                    return from(doc.atomicPatch({method: 'DELETE', error: null}));\n\n                }  else if (doc) {\n\n                    return from(doc.atomicPatch({method: 'DELETE', error: null, time: new Date().getTime()}));\n\n                } else if (data) {\n\n                    const docData: Partial<PwaDocType<T>> = {\n                        tenantUrl: this.makeTenantUrl(tenant, url),\n                        matchUrl: this.makeTenantUrl(tenant, url),\n                        data,\n                        method: 'DELETE',\n                        error: null,\n                        time: new Date().getTime(),\n                        fileFields\n                    };\n\n                    return this.collection$.pipe(\n\n                        switchMap(col => col.atomicUpsert(docData))\n                    );\n\n                } else {\n\n                    return throwError('Document not found while deleting in database');\n                }\n\n            })\n        );\n    }\n\n    ///////////////////\n    // Conflict Actions\n    ///////////////////\n\n    createNew(tenant: string, url: string): Observable<PwaDocument<T>> {\n\n        return this.get(tenant, url).pipe(\n\n            switchMap(doc => {\n\n                if (!!doc && doc.method !== 'GET' && doc.method !== 'POST') {\n\n                    return from(doc.atomicPatch({method:'POST'}));\n                }\n\n                return throwError(`Cannot duplicate this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n            }),\n\n        );\n    }\n\n    deleteConflict(tenant: string, url: string): Observable<boolean> {\n\n        return this.get(tenant, url).pipe(\n\n            switchMap(doc => {\n\n                if (!!doc && doc.method !== 'GET') {\n\n                    return from(doc.remove());\n                }\n\n                return throwError(`Cannot delete this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n            }),\n        );\n    }\n}\n\n\nexport class PwaCollectionAPI<T extends Datatype, Database> {\n\n    private config: PwaCollectionAPICreator<Database> = {\n        restApiCreator: {},\n        collectionApiCreator: {\n            name: 'no_name_pwa_collection_api',\n            db$: of(),\n            collectionEvictTime$: of(86400),\n            collectionSkipDocuments$: of(500),\n            attachments: {},\n            options: {},\n            migrationStrategies: {},\n            autoMigrate: true,\n        },\n        cacheTimeInSeconds: 120\n    };\n\n    collectionAPI: CollectionAPI<T, Database>;\n    restAPI: RestAPI<T>;\n\n    constructor(private _config: Partial<PwaCollectionAPICreator<Database>>, ) {\n\n        this.config = {\n            ...this.config,\n            ...this._config,\n            restApiCreator: {\n                ...this.config.restApiCreator,\n                ...this._config.restApiCreator\n            },\n            collectionApiCreator: {\n                ...this.config.collectionApiCreator,\n                ...this._config.collectionApiCreator\n            }\n        };\n\n        this.restAPI        = new RestAPI(this.config.restApiCreator);\n        this.collectionAPI  = new CollectionAPI(this.config.collectionApiCreator);\n    }\n\n    //////////////\n    // Retrieve\n    //////////////\n\n    downloadRetrieve(doc: PwaDocument<T> | null, tenant: string, url: string, params?: HttpParams): Observable<PwaDocument<T> | null> {\n\n        if (!!doc && doc.method !== 'GET') { return of(doc); }\n\n        // check if document is within cacheTime\n        const currentTime = new Date().getTime();\n\n        if (!!doc && doc.time >= (currentTime - (this.config.cacheTimeInSeconds * 1000))) { return of(doc); }\n\n        return combineLatest([this.restAPI.get(url, params), this.collectionAPI.collection$]).pipe(\n\n            switchMap(([res, col]) => col.atomicUpsert({\n                tenantUrl: this.collectionAPI.makeTenantUrl(tenant, url),\n                matchUrl: this.collectionAPI.makeTenantUrl(tenant, url),\n                data: res,\n                method: 'GET',\n                error: null,\n                time: new Date().getTime(),\n            })),\n\n            catchError(() => of(doc)),\n        );\n    }\n\n    getReactive(tenant: string, url: string, params?: HttpParams, wait = false): Observable<PwaDocument<T>> {\n\n        return this.collectionAPI.get(tenant, url).pipe(\n\n            switchMap(doc => wait ?\n                this.downloadRetrieve(doc, tenant, url, params) :\n                this.downloadRetrieve(doc, tenant, url, params).pipe(startWith(null))\n            ),\n\n            switchMap(() => this.collectionAPI.getReactive(tenant, url)),\n\n            auditTime(1000 / 60),\n\n        );\n    }\n\n    get(tenant: string, url: string, params?: HttpParams): Observable<PwaDocument<T>> {\n\n        return this.getReactive(tenant, url, params, true).pipe(\n\n            take(1)\n        );\n    }\n\n    //////////////\n    // List\n    //////////////\n\n    // tslint:disable-next-line: max-line-length\n    downloadList(res: CollectionListResponse<T>, tenant: string, url: string, params?: HttpParams, indexedbUrl = (data: T, tenantUrl: string) => `${tenantUrl}/${data.id}`): Observable<ListResponse<T>> {\n\n        const currentTime = new Date().getTime();\n\n        // tslint:disable-next-line: radix\n        const limit = parseInt(params?.get('limit') || '100');\n\n        ////////////////////////////////////////////////////////////////\n        // Exclude recents or locally unsynced data in the api results\n        ////////////////////////////////////////////////////////////////\n\n        const ids = res.results\n            // tslint:disable-next-line: max-line-length\n            .filter(v => v.method === 'PUT' || v.method === 'DELETE' || (v.method === 'GET' && v.time >= (currentTime - (this.config.cacheTimeInSeconds * 1000))))\n            .map(v => v.data.id);\n\n        if (ids.length === limit) {\n\n            // pass if all results are excluded\n            return of({next: res.next, previous: res.previous, results: /*res.results.map(r => r.toJSON().data)*/ []});\n        }\n\n        params = params || new CustomHttpParams();\n\n        if (ids.length > 0) {\n\n            if (params.has('exclude:id.in')) {\n\n                params.delete('exclude:id.in');\n\n            }\n\n            params = params.append('exclude:id.in', ids.join(','));\n\n            params = params.set('limit', (limit - ids.length).toString());\n\n        }\n\n        return this.restAPI.list(url, params).pipe(\n\n            catchError(() => of({next: null, previous: null, results: []} as ListResponse<T>)),\n\n            switchMap(networkRes => this.collectionAPI.collection$.pipe(\n\n                switchMap(col => {\n\n                    // map network data to doctype\n                    const atomicWrites = networkRes.results\n                        .map(data => ({\n                            tenantUrl: indexedbUrl(data, this.collectionAPI.makeTenantUrl(tenant, url)),\n                            matchUrl: indexedbUrl(data, this.collectionAPI.makeTenantUrl(tenant, url)),\n                            data,\n                            method: 'GET',\n                            error: null,\n                            time: new Date().getTime(),\n                        })) as PwaDocType<T>[];\n\n                    if (atomicWrites.length > 0) {\n\n                        return from(col.bulkInsert(atomicWrites)).pipe(\n\n                            // tap(() => this.collectionAPI.triggerChange()),\n\n                            map(() => networkRes)\n                        );\n                    }\n\n                    return of(networkRes);\n                })\n            )),\n\n        );\n\n    }\n\n    listReactive(\n        tenant: string,\n        url: string,\n        params?: HttpParams,\n        validQueryKeys = [],\n        indexedbUrl = (data: T, tenantUrl: string) => `${tenantUrl}/${data.id}`,\n        wait = false\n    ): Observable<PwaListResponse<T>> {\n\n        return this.collectionAPI.list(tenant, url, params, validQueryKeys).pipe(\n\n            switchMap(idbRes => wait ?\n                this.downloadList(idbRes, tenant, url, params, indexedbUrl) :\n                this.downloadList(idbRes, tenant, url, params, indexedbUrl).pipe(startWith({next: null, previous: null, results: []}))),\n\n            switchMap((networkRes) => this.collectionAPI.listReactive(tenant, url, params, validQueryKeys).pipe(\n\n                map(res => ({\n                    next: networkRes?.next || res.next,\n                    previous: networkRes?.previous || res.previous,\n                    results: res.results\n                })),\n\n            )),\n\n        ) as Observable<PwaListResponse<T>>;\n\n    }\n\n    list(tenant: string, url: string, params?: HttpParams, validQueryKeys = [], indexedbUrl = (data: T, tenantUrl: string) => `${tenantUrl}/${data.id}`): Observable<PwaListResponse<T>> {\n\n        return this.listReactive(tenant, url, params, validQueryKeys, indexedbUrl, true).pipe(\n\n            take(1)\n        );\n\n    }\n}\n","import { createRxDatabase, addRxPlugin, RxDatabase, RxDatabaseCreator, addPouchPlugin, getRxStoragePouch } from 'rxdb';\nimport { from, Observable } from 'rxjs';\nimport { map, switchMap, startWith, shareReplay, first } from 'rxjs/operators';\nimport { RxDBEncryptionPlugin } from 'rxdb/plugins/encryption';\nimport { RxDBLeaderElectionPlugin } from 'rxdb/plugins/leader-election';\nimport { RxDBValidatePlugin } from 'rxdb/plugins/validate';\nimport { RxDBMigrationPlugin } from 'rxdb/plugins/migration';\n\naddPouchPlugin(require('pouchdb-adapter-idb'));\n\n\nexport interface PwaDatabaseCreator {\n    dbCreator: Partial<RxDatabaseCreator>;\n}\n\n\nexport class PwaDatabaseService<T> {\n\n    // tslint:disable-next-line: variable-name\n    private _db$: Observable<RxDatabase<T>>;\n\n    constructor(private _config: PwaDatabaseCreator) {}\n\n    get db$(): Observable<RxDatabase<T>> {\n\n        if (this._db$) { return this._db$; }\n\n        // add encryption plugin\n        addRxPlugin(RxDBEncryptionPlugin);\n\n        // add leader election plugin\n        addRxPlugin(RxDBLeaderElectionPlugin);\n\n        // add schema validate plugin\n        addRxPlugin(RxDBValidatePlugin);\n\n        // add migration plugin\n        addRxPlugin(RxDBMigrationPlugin);\n\n        const pouchAdapter = getRxStoragePouch('idb');\n\n        pouchAdapter.pouchSettings.revs_limit       = 0,\n        pouchAdapter.pouchSettings.auto_compaction  = true;\n\n        this._db$ = from(createRxDatabase({\n            name: 'pwadb',\n            storage: pouchAdapter,\n            password: 'ubT6LIL7ne2bdpze0V1DaeOGKKqYMWVF',\n            multiInstance: true,\n            eventReduce: true,\n            ...this._config.dbCreator\n        })).pipe(\n\n            switchMap((db: any) => from(db.waitForLeadership()).pipe(\n\n                startWith(null),\n\n                map(() => db),\n            )),\n\n            shareReplay(1),\n\n            first(),\n\n        );\n\n        return this._db$;\n\n    }\n\n}\n","import { Injectable, NgZone } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { auditTime, distinctUntilChanged, map } from 'rxjs/operators';\nimport { enterZone } from './operators.resource';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class ApiProgressService {\n\n    isProgressing$: Observable<boolean>;\n    private progress: BehaviorSubject<boolean[]>;\n\n    constructor(private zone: NgZone) {\n\n        this.progress = new BehaviorSubject([]);\n\n        this.isProgressing$ = this.progress.asObservable().pipe(\n\n            map(v => !!v.length),\n\n            distinctUntilChanged(),\n\n            auditTime(1000 / 60),\n\n            enterZone(zone)\n        );\n    }\n\n    add(): void {\n\n        const newProgress: boolean[] =  this.progress.value;\n\n        newProgress.push(true);\n\n        this.progress.next(newProgress);\n    }\n\n    remove(): void {\n\n        if (this.isProgressing()) {\n\n            const newProgress: boolean[] =  this.progress.value;\n\n            newProgress.pop();\n\n            this.progress.next(newProgress);\n        }\n    }\n\n    isProgressing(): boolean {\n\n        return !!this.progress.value.length;\n    }\n}\n","\nexport function flatten<T>(arr: T[], result = []): any[] {\n\n    for (let i = 0, length = arr.length; i < length; i++) {\n\n        const value = arr[i];\n\n        if (Array.isArray(value)) {\n\n            flatten(value, result);\n\n        } else {\n\n            result.push(value);\n        }\n    }\n\n    return result;\n}\n","import { BehaviorSubject, Observable, combineLatest } from 'rxjs';\nimport { Datatype, PwaDocument } from '../definitions/document';\nimport { HttpParams } from '@angular/common/http';\nimport { PwaListResponse } from '../definitions/collection';\nimport { switchMap, tap, shareReplay, map, filter, auditTime, distinctUntilChanged } from 'rxjs/operators';\nimport { NgZone } from '@angular/core';\nimport { enterZone } from './operators.resource';\nimport { CustomHttpParams } from './customParams.resource';\nimport { flatten } from './misc.resource';\n\n/////////////////////\n// Interfaces\n/////////////////////\n\nexport interface TableDatabase<T extends TableDataType> {\n\n    fetch: (params?: HttpParams) => Observable<PwaListResponse<T>>;\n\n    fetchReactive: (params?: HttpParams) => Observable<PwaListResponse<T>>;\n\n    getDatabase?: (limit?: number) => Database<T>;\n\n    getReactiveDatabase?: (limit?: number) => ReactiveDatabase<T>;\n}\n\nexport interface IBaseDatabase {\n    reset: () => void;\n    loadMore: () => void;\n}\n\nexport interface TableDataType extends Datatype {\n    created_at?: string;\n}\n\n///////////////////\n// Tables\n///////////////////\n\nexport class BaseDatabase<T extends TableDataType> implements IBaseDatabase {\n\n    queueChange: BehaviorSubject<Observable<PwaListResponse<T>>[]>;\n    data: PwaDocument<T>[];\n\n    _isLoadingChange: BehaviorSubject<boolean>;\n    isLoadingChange: Observable<boolean>;\n    lastRes: PwaListResponse<T>;\n\n    // tslint:disable-next-line: variable-name\n    private _httpParams: HttpParams;\n\n    get httpParams() { return this._httpParams; }\n    set httpParams(v: HttpParams) {\n\n        this._httpParams = v;\n\n        this.reset();\n    }\n\n    get isLoading() { return this._isLoadingChange.value; }\n    get offset() { return this.data.length; }\n    get isLoadable(): boolean { return !!this.lastRes?.next; }\n    get limit() { return this.__limit; }\n\n    constructor(private __limit: number, private __zone: NgZone) {\n\n        this.data               = [];\n        this.queueChange        = new BehaviorSubject([]);\n        this._isLoadingChange \t= new BehaviorSubject(false);\n\n        this._httpParams        = new CustomHttpParams();\n\n        this.isLoadingChange    = this._isLoadingChange.asObservable().pipe(\n\n            distinctUntilChanged(),\n\n            enterZone(this.__zone)\n        );\n    }\n\n    reset() {\n\n        this._httpParams = this.httpParams.delete('cursor');\n        this._httpParams = this.httpParams.set('offset', '0');\n        this._httpParams = this.httpParams.set('limit', this.limit.toString());\n\n        if (!this.httpParams.has('ordering')) { this._httpParams = this.httpParams.set('ordering', '-created_at'); }\n    }\n\n    loadMore() {\n\n        // set queryparams from next url\n        if (this.lastRes?.next) {\n\n            const split = this.lastRes.next.split('?');\n\n            if (split.length > 1) {\n\n                split[1].split('&').forEach(q => {\n\n                    const queryParam = q.split('=');\n\n                    this._httpParams = this.httpParams.set(decodeURIComponent(queryParam[0]), decodeURIComponent(queryParam[1]));\n                });\n            }\n        }\n\n        this._httpParams = this.httpParams.set('offset', this.offset.toString());\n        this._httpParams = this.httpParams.set('limit', this.limit.toString());\n    }\n\n}\n\nexport class Database<T extends TableDataType> extends BaseDatabase<T> {\n\n    dataChange: Observable<PwaDocument<T>[]>;\n\n    constructor(private apiService: TableDatabase<T>, private zone: NgZone, private _limit = 20) {\n\n        super(_limit, zone);\n\n        this.dataChange = this.queueChange.asObservable().pipe(\n\n            tap(v => { if (!v.length) { this.reset(); } }),\n\n            filter(v => !!v.length),\n\n            tap(() => this._isLoadingChange.next(true)),\n\n            switchMap(v => combineLatest(v)),\n\n            auditTime(1000 / 60),\n\n            tap(res => this.lastRes = res.length > 0 ? res[res.length - 1] : null),\n\n            map(res => flatten(res.map(v => v.results)) as PwaDocument<T>[]),\n\n            tap(v => this.data = v),\n\n            tap(() => this._isLoadingChange.next(false)),\n\n            shareReplay(1),\n\n        ) as Observable<PwaDocument<T>[]>;\n    }\n\n    getView(httpParams: HttpParams): Observable<PwaListResponse<T>> {\n\n        return this.apiService.fetch(httpParams).pipe(\n\n            shareReplay(1)\n        );\n    }\n\n    reset() {\n\n        super.reset();\n\n        // make view\n        const view = this.getView(this.httpParams);\n\n        // push to queue\n        this.queueChange.next([view]);\n    }\n\n    loadMore() {\n\n        if (this.isLoading) { return; }\n\n        super.loadMore();\n\n        // make view\n        const view = this.getView(this.httpParams);\n\n        // push to queue\n        this.queueChange.next(flatten([this.queueChange.value, view]));\n    }\n\n}\n\n\nexport class ReactiveDatabase<T extends TableDataType> extends BaseDatabase<T> {\n\n    dataChange: Observable<PwaDocument<T>[]>;\n\n    constructor(private apiService: TableDatabase<T>, private zone: NgZone, private _limit = 20) {\n\n        super(_limit, zone);\n\n        this.dataChange = this.queueChange.asObservable().pipe(\n\n            tap(v => { if (!v.length) { this.reset(); } }),\n\n            filter(v => !!v.length),\n\n            tap(() => this._isLoadingChange.next(true)),\n\n            switchMap(v => combineLatest(v)),\n\n            auditTime(1000 / 60),\n\n            tap(res => this.lastRes = res.length > 0 ? res[res.length - 1] : null),\n\n            map(res => flatten(res.map(v => v.results)) as PwaDocument<T>[]),\n\n            tap(v => this.data = v),\n\n            tap(() => this._isLoadingChange.next(false)),\n\n            shareReplay(1),\n\n        ) as Observable<PwaDocument<T>[]>;\n    }\n\n    getView(httpParams: HttpParams): Observable<PwaListResponse<T>> {\n\n        return this.apiService.fetchReactive(httpParams).pipe(\n\n            shareReplay(1)\n        );\n    }\n\n    reset() {\n\n        super.reset();\n\n        // make view\n        const view = this.getView(this.httpParams);\n\n        // push to queue\n        this.queueChange.next([view]);\n    }\n\n    loadMore() {\n\n        if (this.isLoading) { return; }\n\n        super.loadMore();\n\n        // make view\n        const view = this.getView(this.httpParams);\n\n        // push to queue\n        this.queueChange.next(flatten([this.queueChange.value, view]));\n    }\n}\n","import { HttpParams } from '@angular/common/http';\nimport { BehaviorSubject, combineLatest, merge, Observable, of, Subscription } from 'rxjs';\nimport { auditTime, filter, map, mergeMap, shareReplay, switchMap } from 'rxjs/operators';\nimport { Datatype, PwaDocument } from '../definitions/document';\nimport { Database, ReactiveDatabase, TableDataType } from './table.resource';\nimport {CollectionViewer, SelectionChange, DataSource} from '@angular/cdk/collections';\nimport {FlatTreeControl} from '@angular/cdk/tree';\nimport { CustomHttpParams } from './customParams.resource';\nimport { flatten } from './misc.resource';\n\n///////////////////\n// Interfaces\n///////////////////\n\nexport type TreeNode<T extends TableDataType> = {item: PwaDocument<T>, children: Observable<TreeNode<any>[]>};\n\nexport interface DatabaseInformation<T extends TableDataType> {\n    getDatabase: (limit?: number) => Database<T> | ReactiveDatabase<T>;\n    onCreationSetup?: (parentDoc: PwaDocument<T> | null, db: Database<T> | ReactiveDatabase<T>, params: HttpParams) => void;\n    isRecursive: boolean;\n    children: TreeInformation<T>;\n}\n\nexport interface TreeInformation<T extends TableDataType> {\n    [key: string]: DatabaseInformation<T>;\n}\n\n\n///////////////////\n// Trees\n///////////////////\n\n\nexport class TreeDatabase<T extends TableDataType> {\n\n    childTreeMap: Map<PwaDocument<any>, TreeNode<any>>;\n    databaseMap: Map<PwaDocument<any>, Database<any> | ReactiveDatabase<any>>;\n\n    databaseKeyMap: Map<string, Database<any> | ReactiveDatabase<any>>;\n\n    dataChange: Observable<TreeNode<T>[]>;\n\n    private queueChange: BehaviorSubject<any>;\n    // tslint:disable-next-line: variable-name\n    private _httpParams: HttpParams;\n\n    get httpParams() { return this._httpParams; }\n    set httpParams(v: HttpParams) {\n\n        this._httpParams = v;\n\n        this.reset();\n    }\n\n    constructor(private treeInfo: TreeInformation<T>) {\n\n        this.databaseMap    = new Map();\n        this.databaseKeyMap = new Map();\n        this.childTreeMap   = new Map();\n\n        this._httpParams  = new CustomHttpParams();\n        this.queueChange  = new BehaviorSubject(true);\n\n        this.dataChange = this.queueChange.asObservable().pipe(\n\n            switchMap(() => this.buildTree(this.treeInfo, null, this.httpParams)),\n\n            shareReplay(1),\n\n        );\n    }\n\n    buildTree(treeInfo: TreeInformation<T>, parentDoc: PwaDocument<T> = null, parentParams = new CustomHttpParams(), parentKey = null): Observable<TreeNode<T>[]> {\n\n        const treeNodes = Object.keys(treeInfo).map(key => {\n\n            const db = treeInfo[key].getDatabase();\n\n            const currentDatabaseMapKey = parentKey && parentDoc ? `${parentKey}~${parentDoc.tenantUrl}--${key}` : key;\n\n            this.databaseKeyMap.set(currentDatabaseMapKey, db);\n\n            // check current httpParams\n            const possibleParamKeys = parentParams.keys().filter(pk => pk && pk.includes(`${key}--`));\n\n            // create new params associated to this database\n            let currentParams = new CustomHttpParams();\n\n            // extract childParams\n            possibleParamKeys.forEach(pk => {\n\n                const paramName = pk.split(`${key}--`)[1];\n\n                // only set param associated to this database\n                // extra '--' would mean params to nested database\n                if (!paramName.includes('--')) {\n\n                    currentParams = currentParams.set(paramName, parentParams.get(pk));\n                }\n\n            });\n\n            // run callback\n            treeInfo[key].onCreationSetup ? treeInfo[key].onCreationSetup(parentDoc, db, currentParams) : db.httpParams = currentParams;\n\n            return db.dataChange.pipe(\n\n                map(docs => {\n\n                    const obsArr = docs.map(doc => {\n\n                        ///////////////////\n                        // Database Map\n                        ///////////////////\n                        if (!this.databaseMap.has(doc)) { this.databaseMap.set(doc, db); }\n\n                        ///////////////////\n                        // Child Tree\n                        ///////////////////\n\n                        if (!this.childTreeMap.has(doc)) {\n\n                            // add the current treeInfo in children\n                            // if isRecursive == true\n                            if (treeInfo[key].isRecursive) {\n\n                                treeInfo[key].children[key] = treeInfo[key];\n\n                            }\n\n                            const childTree = this.buildTree(treeInfo[key].children, doc, parentParams, currentDatabaseMapKey).pipe(\n\n                                shareReplay(1),\n\n                            ) as Observable<TreeNode<any>[]>;\n\n                            this.childTreeMap.set(doc, {item: doc, children: childTree});\n                        }\n\n                        return this.childTreeMap.get(doc);\n\n                    });\n\n                    return obsArr;\n                }),\n\n            );\n        });\n\n        return combineLatest(treeNodes).pipe(\n\n            map(nodes => flatten(nodes)),\n\n        );\n    }\n\n    reset() {\n\n        this.databaseMap.clear();\n        this.databaseKeyMap.clear();\n        this.childTreeMap.clear();\n\n        this.queueChange.next(true);\n    }\n\n}\n\n/////////////////////\n// DataSource\n/////////////////////\n\n/** Flat node with expandable and level information */\nexport class DynamicFlatNode<T extends TableDataType> {\n    constructor(\n        public item: PwaDocument<T> | string,\n        public level = 1,\n        public expandable = false,\n    ) {}\n}\n\nexport class DynamicTreeFlattener<T, F> {\n\n    flatNodeMap = new Map<T, F>();\n    structuredNodeMap = new Map<F, T>();\n    parentNodeMap = new Map<F, F>();\n\n    constructor(public transformFunction: (node: T, level: number) => F,\n                public getLevel: (node: F) => number,\n                public isExpandable: (node: F) => boolean,\n                public getChildren: (node: T) =>\n                    Observable<T[]> | T[] | undefined | null) {}\n\n    _flattenNode(node: T, level: number): F {\n\n        if (!this.flatNodeMap.has(node)) {\n\n            const flatNode = this.transformFunction(node, level);\n\n            this.flatNodeMap.set(node, flatNode);\n            this.structuredNodeMap.set(flatNode, node);\n        }\n\n        return this.flatNodeMap.get(node);\n    }\n\n    insertChildrenFlatNodes(parentNode: F, children: F[], resultNodes: F[]): F[] {\n\n        const index = resultNodes.indexOf(parentNode);\n\n        resultNodes.splice(index + 1, 0, ...children);\n\n        children.filter(c => !this.parentNodeMap.has(c)).forEach(c => this.parentNodeMap.set(c, parentNode));\n\n        return resultNodes;\n    }\n\n    removeChildrenFlatNodes(parentNode: F, resultNodes: F[]): F[] {\n\n        const index = resultNodes.indexOf(parentNode);\n\n        let count = 0;\n\n        for (let i = index + 1; i < resultNodes.length && this.getLevel(resultNodes[i]) > this.getLevel(parentNode); i++, count++) {}\n\n        const children = resultNodes.splice(index + 1, count);\n\n        children.filter(c => this.parentNodeMap.has(c)).forEach(c => this.parentNodeMap.delete(c));\n\n        return resultNodes;\n    }\n\n    addChildrenFlatNode(parentFlatNode: F, resultNodes: F[]): Observable<F[]> {\n\n        // fetch structuredNode corresponding to this parentFlatNode\n        const structuredNode = this.structuredNodeMap.get(parentFlatNode);\n\n        // fetch structuredChildrenNode corresponding to this structuredNode\n        const structuredChildrenNodes = this.getChildren(structuredNode);\n\n        if (structuredChildrenNodes) {\n\n            if (Array.isArray(structuredChildrenNodes)) {\n\n                const flatChildren = structuredChildrenNodes.map(s => this._flattenNode(s, this.getLevel(parentFlatNode) + 1));\n\n                return of(this.insertChildrenFlatNodes(parentFlatNode, flatChildren, resultNodes));\n\n            } else {\n\n                return structuredChildrenNodes.pipe(\n\n                    map(children => children.map(s => this._flattenNode(s, this.getLevel(parentFlatNode) + 1))),\n\n                    map(flatChildren => {\n\n                        resultNodes = this.removeChildrenFlatNodes(parentFlatNode, resultNodes);\n\n                        return this.insertChildrenFlatNodes(parentFlatNode, flatChildren, resultNodes);\n                    }),\n                );\n\n            }\n        }\n\n        return of(resultNodes);\n    }\n\n    /**\n     * Flatten a list of node type T to flattened version of node F.\n     * Please note that type T may be nested, and the length of `structuredData` may be different\n     * from that of returned list `F[]`.\n     */\n    flattenNodes(structuredData: T[]): F[] {\n\n        return structuredData.map(node => this._flattenNode(node, 0));\n    }\n\n}\n\nexport class DynamicFlatTreeDataSource<T, F extends Datatype> implements DataSource<F> {\n\n    readonly _flattenedData = new BehaviorSubject<F[]>([]);\n    private readonly _data = new BehaviorSubject<T[]>([]);\n\n    subs = new Subscription();\n\n    get data() { return this._data.value; }\n\n    set data(value: T[]) {\n\n        this._data.next(value);\n\n        const flattenedData = this._treeFlattener.flattenNodes(this.data);\n\n        this._treeControl.expansionModel.clear();\n\n        this._treeControl.dataNodes = flattenedData;\n\n        this.flattenedData = flattenedData;\n    }\n\n    mergeData(value: T[]) {\n\n        this._data.next(value);\n\n        const flattenedData = this._treeFlattener.flattenNodes(this.data);\n\n        const mergeObj: {[key: string]: F} = {};\n\n        this.flattenedData.concat(flattenedData).forEach(f => mergeObj[f.id] = f);\n\n        const mergedFlattenedData = Object.values(mergeObj);\n\n        this._treeControl.dataNodes = mergedFlattenedData;\n\n        this.flattenedData = mergedFlattenedData;\n    }\n\n    get flattenedData(): F[] { return this._flattenedData.value; }\n    set flattenedData(v: F[]) { this._flattenedData.next(v); }\n\n    constructor(public _treeControl: FlatTreeControl<F>, public _treeFlattener: DynamicTreeFlattener<T, F>, initialData?: T[]) {\n\n        if (initialData) {\n            // Assign the data through the constructor to ensure that all of the logic is executed.\n            this.data = initialData;\n        }\n    }\n\n    /**\n     * Toggle the node, remove from display list\n     */\n    toggleNode(flatNode: F, expand: boolean): Observable<F[]> {\n\n        if (expand) {\n\n            if (this._treeFlattener.isExpandable(flatNode)) {\n\n                return this._treeFlattener.addChildrenFlatNode(flatNode, this.flattenedData);\n            }\n\n            return this._flattenedData.asObservable();\n\n        } else {\n\n            return of(this._treeFlattener.removeChildrenFlatNodes(flatNode, this.flattenedData));\n        }\n    }\n\n    /** Handle expand/collapse behaviors */\n    handleTreeControl(change: SelectionChange<F>): Observable<F[]> {\n\n        if (change.added) {\n\n            const obsArray = change.added.map(node => this.toggleNode(node, true));\n\n            return combineLatest(obsArray).pipe(\n\n                map((o) => o.length > 0 ? o[obsArray.length - 1] : [])\n            );\n        }\n\n        if (change.removed) {\n\n            const obsArray = change.removed.slice().reverse().map(node => this.toggleNode(node, false));\n\n            return combineLatest(obsArray).pipe(\n\n                map((o) => o.length > 0 ? o[obsArray.length - 1] : [])\n\n            );\n        }\n\n    }\n\n    connect(collectionViewer: CollectionViewer): Observable<F[]> {\n\n        const changeObs = this._treeControl.expansionModel.changed.pipe(\n\n            filter(change => !!(change as SelectionChange<F>).added?.length || !!(change as SelectionChange<F>).removed?.length),\n\n            mergeMap(change => this.handleTreeControl(change as SelectionChange<F>)),\n\n            auditTime(1000 / 60)\n        );\n\n        const subs = changeObs.subscribe((v) => {\n\n            this._treeControl.dataNodes = v;\n\n            this.flattenedData = v;\n        });\n\n        this.subs.add(subs);\n\n        return merge(collectionViewer.viewChange, this._flattenedData.asObservable()).pipe(map(() => this.flattenedData));\n    }\n\n    disconnect(collectionViewer: CollectionViewer): void {\n\n        this.subs.unsubscribe();\n    }\n}\n","import { HttpClient } from '@angular/common/http';\nimport { NgZone } from '@angular/core';\nimport { RxCollectionCreator, RxDatabase } from 'rxdb';\nimport { BehaviorSubject, combineLatest, from, Observable, of, throwError } from 'rxjs';\nimport { auditTime, catchError, concatMap, filter, finalize, first, map, shareReplay, switchMap, tap } from 'rxjs/operators';\nimport { getCollectionCreator, PwaCollection, pwaCollectionMethods } from '../definitions/collection';\nimport { pwaDocMethods, PwaDocument } from '../definitions/document';\nimport { getSynchroniseCollectionCreator, SynchroniseCollection, synchroniseCollectionMethods } from '../definitions/synchronise-collection';\nimport { synchroniseDocMethods, SynchroniseDocType, SynchroniseDocument } from '../definitions/synchronise-document';\nimport { enterZone } from './operators.resource';\nimport { PwaDatabaseService } from './database.resource';\nimport { flatten } from './misc.resource';\n\ninterface Extras {\n    collection: PwaCollection<any>;\n}\n\ntype SynchroniseDocTypeExtras = SynchroniseDocType & Extras;\n\n\nexport interface SyncCollectionServiceCreator {\n    name: string;\n    db$: Observable<RxDatabase<any>>;\n    attachments?: {};\n    options?: {};\n    migrationStrategies?: {};\n    autoMigrate?: boolean;\n    ngZone: NgZone;\n    httpClient: HttpClient;\n}\n\n\nexport class SyncCollectionService {\n\n    // tslint:disable-next-line: variable-name\n    private _collection$: Observable<SynchroniseCollection>;\n\n    private retryChange: BehaviorSubject<boolean>;\n\n    private config: SyncCollectionServiceCreator = {\n        name: 'no_name_sync_collection',\n        db$: of(),\n        attachments: {},\n        options: {},\n        migrationStrategies: {},\n        autoMigrate: true,\n        ngZone: null,\n        httpClient: null,\n    };\n\n    storedCollections: Observable<SynchroniseDocTypeExtras[]>;\n\n    constructor(private _config: Partial<SyncCollectionServiceCreator>) {\n\n        this.config = {\n            ...this.config,\n            ...this._config\n        };\n\n        this.retryChange = new BehaviorSubject(true);\n\n        this.storedCollections = this.collection$.pipe(\n\n            switchMap(col => col.find().$),\n\n            map(docs => docs.map(d => d.toJSON())),\n\n            map(docTypes => {\n\n                // reduce collections to database wise\n                const databasesSchema: {[key: string]: SynchroniseDocType[]} = {};\n\n                docTypes.forEach(d => {\n\n                    const key = d.databaseOptions;\n\n                    key in databasesSchema ? databasesSchema[key].push(d) : databasesSchema[key] = [d];\n                });\n\n                // map RxDatabase and collectionNames\n\n                const databasesMap: {database: Observable<RxDatabase>, collectionInfo: SynchroniseDocType[]}[] = [];\n\n                Object.keys(databasesSchema).forEach(schema => {\n\n                    const pwaDatabaseService = new PwaDatabaseService<any>({dbCreator: {...JSON.parse(schema), ignoreDuplicate: true}});\n\n                    databasesMap.push({database: pwaDatabaseService.db$, collectionInfo: databasesSchema[schema]});\n                });\n\n                return databasesMap;\n            }),\n\n            switchMap(databasesMap => combineLatest(databasesMap.map(m => {\n\n                return m.database.pipe(\n\n                    switchMap(db => {\n\n                        const collectionInfoKeyValue: {[key: string]: SynchroniseDocType} = m.collectionInfo.reduce(\n                            (cur: SynchroniseDocType, acc: {}) => {\n\n                                acc[cur.collectionName] = cur;\n\n                                return acc;\n\n                            }, {});\n\n                        const collections = {};\n\n                        m.collectionInfo.forEach(i => {\n\n                            const collectionOptions = JSON.parse(i.collectionOptions) as RxCollectionCreator;\n\n                            collections[i.collectionName] = getCollectionCreator(\n                                i.collectionName,\n                                pwaCollectionMethods,\n                                pwaDocMethods,\n                                collectionOptions.attachments,\n                                collectionOptions.options,\n                                collectionOptions.migrationStrategies,\n                                collectionOptions.autoMigrate\n                            );\n                        });\n\n                        return from(db.addCollections(collections)).pipe(\n\n                            map(v => Object.keys(v).map(k => ({\n                                collection: v[k] as PwaCollection<any>,\n                                ...collectionInfoKeyValue[k],\n                            })))\n                        );\n                    })\n                );\n\n            }))),\n\n            map(v => flatten(v)),\n\n            tap((v: SynchroniseDocTypeExtras[]) =>  {\n\n                v.forEach(docType => {\n\n                    docType.collection.preSave((plainData, rxDocument) => {\n\n                        // modify anyField before saving\n                        plainData.createdAt = plainData.createdAt || new Date().getTime();\n                        plainData.updatedAt = new Date().getTime();\n\n                    }, false);\n\n                });\n            }),\n\n            shareReplay(1),\n        );\n    }\n\n    get collection$(): Observable<SynchroniseCollection> {\n\n        if (this._collection$) { return this._collection$; }\n\n        const collectionSchema = {};\n\n        collectionSchema[this.config.name] = getSynchroniseCollectionCreator(\n            this.config.name,\n            synchroniseCollectionMethods,\n            synchroniseDocMethods,\n            this.config.attachments,\n            this.config.options,\n            this.config.migrationStrategies,\n            this.config.autoMigrate\n        );\n\n        this._collection$ = this.config.db$.pipe(\n\n            // tslint:disable-next-line: max-line-length\n            switchMap(db => from(db.addCollections(collectionSchema))),\n\n            map(collections => collections[this.config.name]),\n\n            shareReplay(1),\n\n            first()\n        );\n\n        return this._collection$;\n    }\n\n\n    addSynchroniseDocument(data: SynchroniseDocType): Observable<SynchroniseDocument> {\n\n        return this.collection$.pipe(\n\n            switchMap(col => col.atomicUpsert(data))\n        );\n    }\n\n    /////////////////////////////\n    // Synchronisation Management\n    //////////////////////////////\n\n    startSync() {\n\n        this.retryChange.next(true);\n    }\n\n    stopSync() {\n\n        this.retryChange.next(false);\n    }\n\n    unsynchronised(tenant: string, order: 'desc' | 'asc' = 'asc'): Observable<PwaDocument<any>[]> {\n\n        return this.storedCollections.pipe(\n\n            switchMap((collectionsInfo) => {\n\n                const query = {\n                    selector: {\n                        matchUrl: {$regex: new RegExp(`^${tenant}.*`)},\n                        method: {$ne: 'GET'}\n                    }\n                };\n\n                const sortedDocs$ = collectionsInfo.map(k => {\n\n                    return from(k.collection.find(query).$.pipe(\n\n                        auditTime(1000 / 60)\n                    ));\n                });\n\n                return combineLatest(sortedDocs$);\n\n            }),\n\n            map(sortedDocs => flatten(sortedDocs)),\n\n            // tslint:disable-next-line: max-line-length\n            map((sortedDocs: PwaDocument<any>[]) => sortedDocs.sort((a, b) => order === 'asc' ? a.time - b.time : b.time - a.time)),\n\n            enterZone<PwaDocument<any>[]>(this.config.ngZone),\n        );\n    }\n\n    synchronise(tenant: string): Observable<PwaDocument<any> | boolean> {\n\n        const pop: Observable<PwaDocument<any>> = this.unsynchronised(tenant, 'asc').pipe(\n\n            filter(sortedDocs => sortedDocs.length > 0),\n\n            map(sortedDocs => sortedDocs[0]),\n\n        );\n\n        const hit = pop.pipe(\n\n            concatMap(doc => {\n\n                if (doc.method === 'POST') {\n\n                    const url = doc.tenantUrl.split('____')[1].split('/');\n\n                    url.splice(url.length - 1, 1);\n\n                    let formData: FormData | {};\n\n                    if (doc.fileFields.length) {\n\n                        //////////////////\n                        // Multipart/form\n                        //////////////////\n\n                        formData = createFormData(doc.toJSON().data) as FormData;\n\n                        doc.fileFields.forEach(k => {\n\n                            (formData as FormData).delete(k.fileField);\n\n                            (formData as FormData).delete(k.fileNameField);\n\n                            (formData as FormData).delete(k.fileType);\n\n                            if (k.fileKeyField && k.fileField && k.fileType) (formData as FormData).append(k.fileKeyField, new File([new Uint8Array(JSON.parse(doc.data[k.fileField])).buffer], k.fileNameField || 'Unknown', {type: k.fileType}));\n                        });\n\n                    } else {\n\n                        ////////////////////\n                        // Application/json\n                        ////////////////////\n\n                        formData = doc.toJSON().data;\n                    }\n\n                    return this.config.httpClient.post(url.join('/'), formData).pipe(\n\n                        switchMap(res => doc.atomicPatch({\n                            method: 'GET',\n                            data: res,\n                            error: null,\n                            time: new Date().getTime()\n                        })),\n\n                        catchError(err => {\n\n                            return from(doc.atomicPatch({error: JSON.stringify(err)})).pipe(\n\n                                finalize(() => this.retryChange.next(false)),\n                            );\n                        }),\n\n                    );\n\n                } else if (doc.method === 'PUT') {\n\n                    let formData: FormData | {};\n\n                    if (doc.fileFields.length) {\n\n                        //////////////////\n                        // Multipart/form\n                        //////////////////\n\n                        formData = createFormData(doc.toJSON().data) as FormData;\n\n                        doc.fileFields.forEach(k => {\n\n                            (formData as FormData).delete(k.fileField);\n\n                            (formData as FormData).delete(k.fileNameField);\n\n                            (formData as FormData).delete(k.fileType);\n\n                            if (k.fileKeyField && k.fileField && k.fileType) (formData as FormData).append(k.fileKeyField, new File([new Uint8Array(JSON.parse(doc.data[k.fileField])).buffer], k.fileNameField || 'Unknown', {type: k.fileType}));\n                        });\n\n                    } else {\n\n                        ////////////////////\n                        // Application/json\n                        ////////////////////\n\n                        formData = doc.toJSON().data;\n                    }\n\n                    return this.config.httpClient.put(doc.tenantUrl.split('____')[1], formData).pipe(\n\n                        switchMap(res => doc.atomicPatch({\n                            method: 'GET',\n                            data: res,\n                            error: null,\n                            time: new Date().getTime()\n                        })),\n\n                        catchError(err => {\n\n                            return from(doc.atomicPatch({error: JSON.stringify(err)})).pipe(\n\n                                finalize(() => this.retryChange.next(false)),\n                            );\n                        }),\n\n                    );\n\n                } else if (doc.method === 'DELETE') {\n\n                    return this.config.httpClient.delete(doc.tenantUrl.split('____')[1]).pipe(\n\n                        switchMap(() => doc.remove()),\n\n                        catchError(err => {\n\n                            return from(doc.atomicPatch({error: JSON.stringify(err)})).pipe(\n\n                                finalize(() => this.retryChange.next(false)),\n                            );\n                        }),\n\n                    );\n                }\n\n                return throwError(`Document doesn\\'t have valid method. Document: ${JSON.stringify(doc?.toJSON())}`);\n            }),\n\n        );\n\n        return this.retryChange.asObservable().pipe(\n\n            switchMap(trigger => trigger ? hit : of())\n\n        ) as Observable<boolean | PwaDocument<any>>;\n\n    }\n\n    ////////////////////////\n    // Evict Management\n    ////////////////////////\n\n    evict(): Observable<any> {\n\n        return this.storedCollections.pipe(\n\n            switchMap(collectionInfo => {\n\n                const evicts = collectionInfo.map(k => {\n\n                    const cacheAllowedAge = new Date().getTime() - (k.collectionEvictTime * 1000);\n\n                    return k.collection.insert$.pipe(\n\n                        // tslint:disable-next-line: max-line-length\n                        switchMap(() => k.collection.find({selector: {$and: [{method: {$eq: 'GET'}}, {time: {$lt: cacheAllowedAge}}]}}).remove())\n                    );\n\n                });\n\n                return combineLatest(evicts);\n            }),\n        );\n\n    }\n\n    // tslint:disable-next-line: max-line-length\n    skipTrim(): Observable<any> {\n\n        return this.storedCollections.pipe(\n\n            switchMap((collectionInfo) => {\n\n                const skipTrims = collectionInfo.map(k => {\n\n                    return k.collection.insert$.pipe(\n\n                        // tslint:disable-next-line: max-line-length\n                        switchMap(() => k.collection.find({selector: {method: {$eq: 'GET'}}, sort: [{time: 'desc'}], skip: k.collectionSkipDocuments}).remove())\n                    );\n                });\n\n                return combineLatest(skipTrims);\n            }),\n        );\n    }\n\n    ////////////////////////\n    // Conflict Management\n    ////////////////////////\n\n    createNew(doc: PwaDocument<any>): Observable<PwaDocument<any>> {\n\n        if (!!doc && doc.method !== 'GET' && doc.method !== 'POST') {\n\n            return from(doc.atomicPatch({method: 'POST'}));\n        }\n\n        return throwError(`Cannot duplicate this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n    }\n\n    deleteConflict(doc: PwaDocument<any>): Observable<boolean> {\n\n        if (!!doc && doc.method !== 'GET') {\n\n            return from(doc.remove());\n        }\n\n        return throwError(`Cannot delete this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n    }\n}\n\n\nexport function createFormData(object: Object, form?: FormData, namespace?: string): FormData {\n\n    let formData = form || new FormData();\n\n    for (let propertyName in object) {\n\n        const formKey = namespace ? `${namespace}.${propertyName}` : propertyName;\n\n        if (object[propertyName] instanceof Date) {\n\n            formData.append(formKey, object[propertyName].toISOString());\n\n        } else if (object[propertyName] instanceof Array) {\n\n            object[propertyName].forEach((element: any, index: number) => {\n\n                const tempFormKey = `${formKey}-${index}`;\n\n                if (typeof element === 'object') {\n\n                    createFormData(element, formData, tempFormKey);\n\n                } else {\n\n                    formData.append(tempFormKey, element.toString());\n                }\n\n            });\n\n        } else if (typeof object[propertyName] === 'object' && !(object[propertyName] instanceof File) && object[propertyName] !== null && object[propertyName] !== undefined) {\n\n            createFormData(object[propertyName], formData, formKey);\n\n        } else {\n\n            formData.append(formKey, object[propertyName] === null || object[propertyName] === undefined ? '' : object[propertyName].toString());\n        }\n    }\n\n    return formData;\n\n    // const formData = form || new FormData();\n\n    // for (const property in object) {\n\n    //     let formKey = '';\n\n    //     if (isArray) {\n\n    //         formKey = namespace ? `${namespace}[${property}]` : property;\n\n    //     } else {\n\n    //         formKey = namespace ? `${namespace}.${property}` : property;\n    //     }\n\n    //     if (object[property] instanceof Date) {\n\n    //         formData.append(formKey, object[property].toISOString());\n\n    //     } else if (typeof object[property] === 'object' && !(object[property] instanceof File) && object[property] !== null && object[property] !== undefined) {\n\n    //         createFormData(object[property], formData, formKey, typeof object[property] === 'object' && Array.isArray(object[property]));\n\n    //     } else {\n\n    //         formData.append(formKey, object[property] === null || object[property] === undefined ? '' : object[property]);\n    //     }\n    // }\n\n    // return formData;\n}\n","import { addPouchPlugin, addRxPlugin, createRxDatabase, getRxStoragePouch, RxDatabase, RxDatabaseCreator } from 'rxdb';\nimport { from, Observable } from 'rxjs';\nimport { RxDBEncryptionPlugin } from 'rxdb/plugins/encryption';\nimport { RxDBLeaderElectionPlugin } from 'rxdb/plugins/leader-election';\nimport { RxDBValidatePlugin } from 'rxdb/plugins/validate';\nimport { first, map, shareReplay, startWith, switchMap } from 'rxjs/operators';\n\naddPouchPlugin(require('pouchdb-adapter-idb'));\n\n\nexport interface SyncDatabaseServiceCreator {\n    dbCreator: Partial<RxDatabaseCreator>;\n}\n\n\nexport class SyncDatabaseService {\n\n    // tslint:disable-next-line: variable-name\n    private _db$: Observable<RxDatabase<any>>;\n\n    constructor(private _config: SyncDatabaseServiceCreator) {}\n\n    get db$(): Observable<RxDatabase<any>> {\n\n        if (this._db$) { return this._db$; }\n\n        // add encryption plugin\n        addRxPlugin(RxDBEncryptionPlugin);\n\n        // add leader election plugin\n        addRxPlugin(RxDBLeaderElectionPlugin);\n\n        // add schema validate plugin\n        addRxPlugin(RxDBValidatePlugin);\n\n        const pouchAdapter = getRxStoragePouch('idb');\n\n        pouchAdapter.pouchSettings.revs_limit       = 0,\n        pouchAdapter.pouchSettings.auto_compaction  = true;\n\n        this._db$ = from(createRxDatabase({\n            name: 'synchronise/pwadb',\n            storage: pouchAdapter,\n            password: 'ubT6LIL7ne2bdpze0V1DaeOGKKqYMWVF',\n            multiInstance: true,\n            eventReduce: true,\n            ...this._config.dbCreator\n        })).pipe(\n\n            switchMap((db: any) => from(db.waitForLeadership()).pipe(\n\n                startWith(null),\n\n                map(() => db),\n            )),\n\n            shareReplay(1),\n\n            first(),\n\n        );\n\n        return this._db$;\n    }\n\n}\n\n"],"names":["filter"],"mappings":"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"}},"fesm2015":{"code":"import { HttpParams } from '@angular/common/http';\nimport { tap, switchMap, timeout, finalize, shareReplay, take, map, catchError, startWith, auditTime, first, distinctUntilChanged, filter as filter$1, mergeMap, concatMap } from 'rxjs/operators';\nimport { Observable, of, combineLatest, from, throwError, BehaviorSubject, Subscription, merge } from 'rxjs';\nimport { addPouchPlugin, addRxPlugin, getRxStoragePouch, createRxDatabase } from 'rxdb';\nimport { RxDBEncryptionPlugin } from 'rxdb/plugins/encryption';\nimport { RxDBLeaderElectionPlugin } from 'rxdb/plugins/leader-election';\nimport { RxDBValidatePlugin } from 'rxdb/plugins/validate';\nimport { RxDBMigrationPlugin } from 'rxdb/plugins/migration';\nimport * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\n\nconst getSchema = (name) => ({\n    title: name + '_store',\n    description: `Store ${name} types of data in the collection`,\n    keyCompression: false,\n    version: 4,\n    type: 'object',\n    primaryKey: 'tenantUrl',\n    properties: {\n        tenantUrl: {\n            type: 'string',\n            primary: true,\n        },\n        matchUrl: {\n            type: 'string',\n        },\n        method: {\n            type: 'string',\n            enum: ['GET', 'POST', 'PUT', 'DELETE'],\n        },\n        data: {\n            type: ['object', 'null'],\n        },\n        time: {\n            type: 'integer',\n        },\n        error: {\n            type: ['string', 'null'],\n        },\n        fileFields: {\n            type: ['array'],\n            default: [],\n            items: {\n                type: ['object'],\n                properties: {\n                    fileField: {\n                        type: ['string']\n                    },\n                    fileNameField: {\n                        type: ['string']\n                    },\n                    fileType: {\n                        type: ['string']\n                    },\n                    fileKeyField: {\n                        type: ['string']\n                    }\n                }\n            }\n        },\n        createdAt: {\n            type: 'integer',\n        },\n        updatedAt: {\n            type: 'integer'\n        }\n    },\n    encrypted: [\n        'data',\n        'fileFields'\n    ],\n});\nconst pwaDocMethods = {};\n\nconst getCollectionCreator = (name, collectionMethods, documentMethods, attachments = {}, options = {}, migrationStrategies = {}, autoMigrate = true) => ({\n    name,\n    schema: getSchema(name),\n    statics: collectionMethods,\n    methods: documentMethods,\n    attachments,\n    options,\n    migrationStrategies: Object.assign({ 1: (oldDoc) => {\n            oldDoc.createdAt = new Date().getTime();\n            oldDoc.updatedAt = new Date().getTime();\n            return oldDoc;\n        }, 2: (oldDoc) => {\n            oldDoc.fileFields = [];\n            return oldDoc;\n        }, 3: (oldDoc) => {\n            oldDoc.fileFields = [];\n            return oldDoc;\n        }, 4: (oldDoc) => {\n            oldDoc.fileFields = [];\n            return oldDoc;\n        } }, migrationStrategies),\n    autoMigrate,\n});\nconst pwaCollectionMethods = {};\n\nconst getSynchroniseSchema = () => ({\n    title: 'synchronise_store',\n    description: `Stores database & collectionNames of data in the collection`,\n    keyCompression: false,\n    version: 0,\n    type: 'object',\n    primaryKey: 'id',\n    properties: {\n        id: {\n            type: 'string',\n            primary: true,\n        },\n        databaseOptions: {\n            type: 'string',\n        },\n        collectionName: {\n            type: 'string'\n        },\n        collectionOptions: {\n            type: 'string',\n        },\n        collectionEvictTime: {\n            type: 'integer'\n        },\n        collectionSkipDocuments: {\n            type: 'integer'\n        },\n        collectionReqTitleFieldName: {\n            type: 'string'\n        },\n        collectionReqSubTitleFieldName: {\n            type: ['string', 'null']\n        },\n        collectionReqIconFieldName: {\n            type: ['string', 'null']\n        }\n    },\n    encrypted: [\n        'databaseOptions',\n        'collectionName',\n        'collectionOptions',\n        'collectionEvictTime',\n        'collectionSkipDocuments',\n        'collectionReqTitleFieldName',\n        'collectionReqSubTitleFieldName',\n        'collectionReqIconFieldName',\n    ],\n});\nconst synchroniseDocMethods = {};\n\nconst getSynchroniseCollectionCreator = (name, collectionMethods, documentMethods, attachments = {}, options = {}, migrationStrategies = {}, autoMigrate = true) => ({\n    name,\n    schema: getSynchroniseSchema(),\n    pouchSettings: {\n        revs_limit: 0,\n        auto_compaction: true,\n    },\n    statics: collectionMethods,\n    methods: documentMethods,\n    attachments,\n    options,\n    migrationStrategies,\n    autoMigrate,\n});\nconst synchroniseCollectionMethods = {};\n\nclass CustomEncoder {\n    encodeKey(key) {\n        return encodeURIComponent(key);\n    }\n    encodeValue(value) {\n        return encodeURIComponent(value);\n    }\n    decodeKey(key) {\n        return decodeURIComponent(key);\n    }\n    decodeValue(value) {\n        return decodeURIComponent(value);\n    }\n}\nclass CustomHttpParams extends HttpParams {\n    constructor(options) {\n        options = Object.assign(Object.assign({}, (options || {})), { encoder: new CustomEncoder() });\n        super(options);\n    }\n}\n\nfunction parseNumber(fieldValue, inputValue) {\n    const parsedFieldValue = Number((fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.toString()) || '');\n    const parsedInputValue = Number((inputValue === null || inputValue === void 0 ? void 0 : inputValue.toString()) || '');\n    return isNaN(parsedFieldValue) && isNaN(parsedInputValue) ? null : { parsedFieldValue, parsedInputValue };\n}\nfunction parseDate(fieldValue, inputValue) {\n    const parsedFieldValue = Date.parse((fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.toString()) || '');\n    const parsedInputValue = Date.parse((inputValue === null || inputValue === void 0 ? void 0 : inputValue.toString()) || '');\n    return isNaN(parsedFieldValue) && isNaN(parsedInputValue) ? null : { parsedFieldValue, parsedInputValue };\n}\nfunction parseBoolean(fieldValue, inputValue) {\n    const parsedFieldValue = (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.toString().toLowerCase()) === 'true' ? true : (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.toString().toLowerCase()) === 'false' ? false : null;\n    const parsedInputValue = (inputValue === null || inputValue === void 0 ? void 0 : inputValue.toString().toLowerCase()) === 'true' ? true : (inputValue === null || inputValue === void 0 ? void 0 : inputValue.toString().toLowerCase()) === 'false' ? false : null;\n    return parsedFieldValue === null || parsedInputValue === null ? null : { parsedFieldValue, parsedInputValue };\n}\nconst eq = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue === isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue === isNumber.parsedInputValue;\n    }\n    const isBoolean = parseBoolean(v.data[field], inputValue);\n    if (isBoolean) {\n        return isBoolean.parsedFieldValue === isBoolean.parsedInputValue;\n    }\n    return v.data[field] === inputValue;\n};\nconst gte = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue >= isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue >= isNumber.parsedInputValue;\n    }\n    return v.data[field] >= inputValue;\n};\nconst lte = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue <= isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue <= isNumber.parsedInputValue;\n    }\n    return v.data[field] <= inputValue;\n};\nconst gt = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue > isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue > isNumber.parsedInputValue;\n    }\n    return v.data[field] > inputValue;\n};\nconst lt = (v, field, inputValue) => {\n    const isDate = parseDate(v.data[field], inputValue);\n    if (isDate) {\n        return isDate.parsedFieldValue < isDate.parsedInputValue;\n    }\n    const isNumber = parseNumber(v.data[field], inputValue);\n    if (isNumber) {\n        return isNumber.parsedFieldValue < isNumber.parsedInputValue;\n    }\n    return v.data[field] < inputValue;\n};\nconst range = (v, field, inputValue) => {\n    const values = inputValue.toString().split(',');\n    const isDate1 = parseDate(v.data[field], values[0]);\n    const isDate2 = parseDate(v.data[field], values[1]);\n    if (isDate1 && isDate2) {\n        return isDate1.parsedFieldValue >= isDate1.parsedInputValue && isDate2.parsedFieldValue < isDate2.parsedInputValue;\n    }\n    const isNumber1 = parseNumber(v.data[field], values[0]);\n    const isNumber2 = parseNumber(v.data[field], values[1]);\n    if (isNumber1 && isNumber2) {\n        return isNumber1.parsedFieldValue >= isNumber1.parsedInputValue && isNumber2.parsedFieldValue < isNumber2.parsedInputValue;\n    }\n    return v.data[field] >= values[0] && v.data[field] < values[1];\n};\nconst startswith = (v, field, inputValue) => { var _a; return (_a = v.data[field]) === null || _a === void 0 ? void 0 : _a.toString().startsWith(inputValue); };\nconst endswith = (v, field, inputValue) => { var _a; return (_a = v.data[field]) === null || _a === void 0 ? void 0 : _a.toString().endsWith(inputValue); };\nconst iexact = (v, field, inputValue) => { var _a; return !!((_a = v.data[field]) === null || _a === void 0 ? void 0 : _a.toString().match(new RegExp(`^${inputValue}$`, 'i'))); };\nconst exact = (v, field, inputValue) => { var _a; return !!((_a = v.data[field]) === null || _a === void 0 ? void 0 : _a.toString().match(new RegExp(`^${inputValue}$`))); };\nconst icontains = (v, field, inputValue) => { var _a; return (_a = v.data[field]) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase().includes((inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) || ''); };\nconst contains = (v, field, inputValue) => { var _a; return (_a = v.data[field]) === null || _a === void 0 ? void 0 : _a.toString().includes(inputValue); };\nconst isnull = (v, field, inputValue) => (inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) === 'true' ? v.data[field] === null : v.data[field] !== null;\nfunction getQuery(key, value) {\n    if (key.includes('distinct')) {\n        return { queryType: 'distinct', fields: value.split(',') };\n    }\n    else if (key.includes('only')) {\n        return { queryType: 'only', fields: value.split(',') };\n    }\n    else if (key.includes('ordering')) {\n        return { queryType: 'ordering', fields: value.split(',') };\n    }\n    else if (key.includes('exclude')) {\n        const fieldAndLookup = key.split(':')[1].split('.');\n        return { queryType: 'exclude', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] : 'eq', inputValue: value };\n    }\n    else if (key.includes('filter')) {\n        const fieldAndLookup = key.split(':')[1].split('.');\n        return { queryType: 'filter', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] : 'eq', inputValue: value };\n    }\n    else {\n        const fieldAndLookup = key.split('.');\n        return { queryType: 'filter', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] : 'eq', inputValue: value };\n    }\n}\nfunction queryFilter(validQueryKeys, params, docs) {\n    if (params) {\n        const keys = params.keys();\n        keys.forEach(k => {\n            if (validQueryKeys.indexOf(k) > -1) {\n                const query = getQuery(k, params.getAll(k).join(','));\n                if (query.queryType === 'filter') {\n                    docs = filter(query.fields[0], query.inputValue, docs, query.lookup);\n                }\n            }\n        });\n        keys.forEach(k => {\n            if (validQueryKeys.indexOf(k) > -1) {\n                const query = getQuery(k, params.getAll(k).join(','));\n                if (query.queryType === 'exclude') {\n                    docs = exclude(query.fields[0], query.inputValue, docs, query.lookup);\n                }\n            }\n        });\n        keys.forEach(k => {\n            if (validQueryKeys.indexOf(k) > -1) {\n                const query = getQuery(k, params.getAll(k).join(','));\n                if (query.queryType === 'ordering') {\n                    docs = orderBy(query.fields, docs);\n                }\n            }\n        });\n        keys.forEach(k => {\n            if (validQueryKeys.indexOf(k) > -1) {\n                const query = getQuery(k, params.getAll(k).join(','));\n                if (query.queryType === 'distinct') {\n                    docs = distinct(query.fields, docs);\n                }\n            }\n        });\n    }\n    return docs;\n}\nfunction filter(field, inputValue, docs, lookup, isExclude = false) {\n    let f = (v) => inputValue.split(',').reduce((acc, cur) => acc || eq(v, field, cur), false);\n    if (lookup === 'gte') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || gte(v, field, cur), false);\n    }\n    if (lookup === 'lte') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || lte(v, field, cur), false);\n    }\n    if (lookup === 'gt') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || gt(v, field, cur), false);\n    }\n    if (lookup === 'lt') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || lt(v, field, cur), false);\n    }\n    if (lookup === 'range') {\n        f = v => range(v, field, inputValue);\n    }\n    if (lookup === 'startswith') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || startswith(v, field, cur), false);\n    }\n    if (lookup === 'endswith') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || endswith(v, field, cur), false);\n    }\n    if (lookup === 'iexact') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || iexact(v, field, cur), false);\n    }\n    if (lookup === 'exact') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || exact(v, field, cur), false);\n    }\n    if (lookup === 'icontains') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || icontains(v, field, cur), false);\n    }\n    if (lookup === 'contains') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || contains(v, field, cur), false);\n    }\n    if (lookup === 'isnull') {\n        f = v => inputValue.split(',').reduce((acc, cur) => acc || isnull(v, field, cur), false);\n    }\n    return docs.filter((v) => {\n        const o = f(v);\n        return isExclude ? !o : o;\n    });\n}\nfunction exclude(field, inputValue, docs, lookup) {\n    return filter(field, inputValue, docs, lookup, true);\n}\nfunction distinct(fields, docs) {\n    const uniques = new Set();\n    const distinctArray = [];\n    docs.forEach(v => {\n        const key = fields.reduce((acc, cur) => { var _a; return acc += `-${((_a = v.data[cur]) === null || _a === void 0 ? void 0 : _a.toString()) || 'null'}`; }, '');\n        if (!uniques.has(key)) {\n            uniques.add(key);\n            distinctArray.push(v);\n        }\n    });\n    return distinctArray;\n}\nfunction orderBy(fields, docs) {\n    return docs.sort((a, b) => {\n        var _a, _b;\n        for (let i = 0; i < fields.length; i++) {\n            const order = fields[i].indexOf('-') === 0 ? 'desc' : 'asc';\n            const parseFieldName = order === 'desc' ? fields[i].split('-')[1] : fields[i];\n            if (!(parseFieldName in (a === null || a === void 0 ? void 0 : a.data)) || !(parseFieldName in (b === null || b === void 0 ? void 0 : b.data))) {\n                continue;\n            }\n            let output = 0;\n            const isDate = parseDate(a.data[parseFieldName], b.data[parseFieldName]);\n            if (isDate && order === 'asc' && isDate.parsedFieldValue !== isDate.parsedInputValue) {\n                output = isDate.parsedFieldValue - isDate.parsedInputValue;\n                if (output > 0 || output < 0) {\n                    return output;\n                }\n            }\n            if (isDate && order === 'desc' && isDate.parsedInputValue !== isDate.parsedFieldValue) {\n                output = isDate.parsedInputValue - isDate.parsedFieldValue;\n                if (output > 0 || output < 0) {\n                    return output;\n                }\n            }\n            const isNumber = parseNumber(a.data[parseFieldName], b.data[parseFieldName]);\n            if (isNumber && order === 'asc' && isNumber.parsedFieldValue !== isNumber.parsedInputValue) {\n                output = isNumber.parsedFieldValue - isNumber.parsedInputValue;\n                if (output > 0 || output < 0) {\n                    return output;\n                }\n            }\n            if (isNumber && order === 'desc' && isNumber.parsedInputValue !== isNumber.parsedFieldValue) {\n                output = isNumber.parsedInputValue - isNumber.parsedFieldValue;\n                if (output > 0 || output < 0) {\n                    return output;\n                }\n            }\n            const valueA = ((_a = a.data[parseFieldName]) === null || _a === void 0 ? void 0 : _a.toString()) || '';\n            const valueB = ((_b = b.data[parseFieldName]) === null || _b === void 0 ? void 0 : _b.toString()) || '';\n            output = order === 'asc' ? valueA.localeCompare(valueB) : valueA.localeCompare(valueB) * -1;\n            if (output > 0 || output < 0) {\n                return output;\n            }\n        }\n        return 0;\n    });\n}\n\nfunction enterZone(zone) {\n    return (source) => new Observable(observer => source.subscribe({\n        next: (x) => zone.run(() => observer.next(x)),\n        error: (err) => observer.error(err),\n        complete: () => observer.complete()\n    }));\n}\n\nclass RestAPI {\n    constructor(config) {\n        this.config = config;\n        this.cache = new Map();\n    }\n    get(url, params) {\n        const paramsUrl = params === null || params === void 0 ? void 0 : params.keys().map(k => `${k}=${params.getAll(k).join(',')}`).join('&');\n        const cacheKey = `${url}${paramsUrl ? '?' + paramsUrl : ''}`;\n        const req = of(true).pipe(tap(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.add();\n            }\n        }), switchMap(() => this.config.httpClient.get(cacheKey)), timeout(7500), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n    post(url, data) {\n        const cacheKey = url;\n        const req = of(true).pipe(tap(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.add();\n            }\n        }), switchMap(() => this.config.httpClient.post(url, data)), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n    put(url, data) {\n        const cacheKey = url;\n        const req = of(true).pipe(tap(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.add();\n            }\n        }), switchMap(() => this.config.httpClient.put(url, data)), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n    list(url, params) {\n        const paramsUrl = params === null || params === void 0 ? void 0 : params.keys().map(k => `${k}=${params.getAll(k).join(',')}`).join('&');\n        const cacheKey = `${url}${paramsUrl ? '?' + paramsUrl : ''}`;\n        const req = of(true).pipe(tap(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.add();\n            }\n        }), switchMap(() => this.config.httpClient.get(cacheKey)), timeout(7500), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n    delete(url) {\n        const cacheKey = url;\n        const req = of(true).pipe(tap(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.add();\n            }\n        }), switchMap(() => this.config.httpClient.delete(url)), finalize(() => {\n            if (!!this.config.apiProgress) {\n                this.config.apiProgress.remove();\n            }\n            if (this.cache.has(cacheKey)) {\n                this.cache.delete(cacheKey);\n            }\n        }), shareReplay(1));\n        if (!this.cache.has(cacheKey)) {\n            this.cache.set(cacheKey, req);\n        }\n        return this.cache.get(cacheKey);\n    }\n}\nclass CollectionAPI {\n    constructor(_config) {\n        this._config = _config;\n        this.config = {\n            name: 'no_name_collection_api',\n            db$: of(),\n            collectionEvictTime$: of(86400),\n            collectionSkipDocuments$: of(500),\n            attachments: {},\n            options: {},\n            migrationStrategies: {},\n            autoMigrate: true,\n            ngZone: null\n        };\n        this.cache = new Map();\n        this.config = Object.assign(Object.assign({}, this.config), this._config);\n    }\n    get collection$() {\n        if (this._collection$) {\n            return this._collection$;\n        }\n        const collectionSchema = {};\n        collectionSchema[this.config.name] = getCollectionCreator(this.config.name, pwaCollectionMethods, pwaDocMethods, this.config.attachments, this.config.options, this.config.migrationStrategies, this.config.autoMigrate);\n        this._collection$ = this.config.db$.pipe(switchMap(db => {\n            if (this.config.name in db) {\n                return of(db[this.config.name]);\n            }\n            return combineLatest([\n                from(db.addCollections(collectionSchema)),\n                this.config.collectionEvictTime$,\n                this.config.collectionSkipDocuments$\n            ]).pipe(take(1), switchMap(([collections, collectionEvictTime, collectionSkipDocuments]) => {\n                if (this.config.synchroniseService) {\n                    const data = {\n                        id: db.name + '-' + this.config.name,\n                        databaseOptions: JSON.stringify({\n                            name: db.name,\n                            eventReduce: db.eventReduce,\n                            multiInstance: db.multiInstance,\n                            options: db.options,\n                            password: db.password,\n                        }),\n                        collectionEvictTime,\n                        collectionSkipDocuments,\n                        collectionName: this.config.name,\n                        collectionOptions: JSON.stringify({\n                            name: this.config.name,\n                            schema: getSchema(this.config.name),\n                            attachments: collections[this.config.name].attachments,\n                            autoMigrate: true,\n                            cacheReplacementPolicy: collections[this.config.name].cacheReplacementPolicy,\n                            methods: collections[this.config.name].methods,\n                            migrationStrategies: collections[this.config.name].migrationStrategies,\n                            options: collections[this.config.name].options,\n                            statics: collections[this.config.name].statics,\n                        })\n                    };\n                    return this.config.synchroniseService.addSynchroniseDocument(data).pipe(map(() => collections[this.config.name]));\n                }\n                else {\n                    return of(collections).pipe(map(() => collections[this.config.name]));\n                }\n            }));\n        }), tap(col => col.preSave((plainData, rxDocument) => {\n            plainData.createdAt = plainData.createdAt || new Date().getTime();\n            plainData.updatedAt = new Date().getTime();\n        }, false)), shareReplay(1), take(1));\n        return this._collection$;\n    }\n    makeTenantUrl(tenant, url) {\n        return `${tenant}____${url}`;\n    }\n    filterDocs(docs, url, params, validQueryKeys = []) {\n        return docs.pipe(map(allDocs => queryFilter(validQueryKeys, params, allDocs)), map(allDocs => {\n            const start = parseInt((params === null || params === void 0 ? void 0 : params.get('offset')) || '0');\n            const end = start + parseInt((params === null || params === void 0 ? void 0 : params.get('limit')) || '100');\n            const next = allDocs.length - end > 0 ? `${url}?${params.set('offset', end.toString()).toString()}` : null;\n            const previous = start > 0 ? `${url}?${params.set('offset', start.toString()).toString()}` : null;\n            return { next, previous, results: allDocs.slice(start, end), count: allDocs.length };\n        }));\n    }\n    getReactive(tenant, url) {\n        const cacheKey = tenant + url;\n        if (!this.cache.has(cacheKey)) {\n            const doc = this.collection$.pipe(switchMap(col => col.findOne({ selector: { tenantUrl: { $eq: this.makeTenantUrl(tenant, url) } } }).$), shareReplay(1), enterZone(this.config.ngZone));\n            this.cache.set(cacheKey, doc);\n        }\n        return this.cache.get(cacheKey);\n    }\n    get(tenant, url) {\n        return this.getReactive(tenant, url).pipe(take(1));\n    }\n    listReactive(tenant, url, params, validQueryKeys = []) {\n        const cacheKey = tenant + url;\n        if (!this.cache.has(cacheKey)) {\n            const docs = this.collection$.pipe(switchMap(col => col.find({ selector: { matchUrl: { $regex: new RegExp(`^${this.makeTenantUrl(tenant, url)}.*`) } } }).$), shareReplay(1));\n            this.cache.set(cacheKey, docs);\n        }\n        return this.filterDocs(this.cache.get(cacheKey), url, params, validQueryKeys).pipe(enterZone(this.config.ngZone));\n    }\n    list(tenant, url, params, validQueryKeys = []) {\n        return this.listReactive(tenant, url, params, validQueryKeys).pipe(take(1));\n    }\n    post(tenant, url, data, fileFields = []) {\n        return this.collection$.pipe(switchMap(col => col.atomicUpsert({\n            tenantUrl: `${this.makeTenantUrl(tenant, url)}/${data.id}`,\n            matchUrl: `${this.makeTenantUrl(tenant, url)}/${data.id}`,\n            method: 'POST',\n            data,\n            error: null,\n            time: new Date().getTime(),\n            fileFields\n        })));\n    }\n    put(tenant, url, data, fileFields = []) {\n        return combineLatest([this.get(tenant, url), this.collection$]).pipe(switchMap(([doc, col]) => {\n            if (doc) {\n                return doc.atomicPatch({\n                    method: doc.method !== 'POST' ? 'PUT' : doc.method,\n                    data,\n                    error: null,\n                    time: doc.method === 'GET' ? new Date().getTime() : doc.time,\n                    fileFields\n                });\n            }\n            else {\n                const docData = {\n                    tenantUrl: this.makeTenantUrl(tenant, url),\n                    matchUrl: this.makeTenantUrl(tenant, url),\n                    data,\n                    method: 'PUT',\n                    error: null,\n                    time: new Date().getTime(),\n                    fileFields\n                };\n                return col.atomicUpsert(docData);\n            }\n        }));\n    }\n    delete(tenant, url, data, fileFields = []) {\n        return this.get(tenant, url).pipe(switchMap(doc => {\n            if (doc && doc.method === 'POST') {\n                return from(doc.remove());\n            }\n            else if (doc && (doc.method === 'PUT' || doc.method === 'DELETE')) {\n                return from(doc.atomicPatch({ method: 'DELETE', error: null }));\n            }\n            else if (doc) {\n                return from(doc.atomicPatch({ method: 'DELETE', error: null, time: new Date().getTime() }));\n            }\n            else if (data) {\n                const docData = {\n                    tenantUrl: this.makeTenantUrl(tenant, url),\n                    matchUrl: this.makeTenantUrl(tenant, url),\n                    data,\n                    method: 'DELETE',\n                    error: null,\n                    time: new Date().getTime(),\n                    fileFields\n                };\n                return this.collection$.pipe(switchMap(col => col.atomicUpsert(docData)));\n            }\n            else {\n                return throwError('Document not found while deleting in database');\n            }\n        }));\n    }\n    createNew(tenant, url) {\n        return this.get(tenant, url).pipe(switchMap(doc => {\n            if (!!doc && doc.method !== 'GET' && doc.method !== 'POST') {\n                return from(doc.atomicPatch({ method: 'POST' }));\n            }\n            return throwError(`Cannot duplicate this document. Document: ${JSON.stringify((doc === null || doc === void 0 ? void 0 : doc.toJSON()) || {})}`);\n        }));\n    }\n    deleteConflict(tenant, url) {\n        return this.get(tenant, url).pipe(switchMap(doc => {\n            if (!!doc && doc.method !== 'GET') {\n                return from(doc.remove());\n            }\n            return throwError(`Cannot delete this document. Document: ${JSON.stringify((doc === null || doc === void 0 ? void 0 : doc.toJSON()) || {})}`);\n        }));\n    }\n}\nclass PwaCollectionAPI {\n    constructor(_config) {\n        this._config = _config;\n        this.config = {\n            restApiCreator: {},\n            collectionApiCreator: {\n                name: 'no_name_pwa_collection_api',\n                db$: of(),\n                collectionEvictTime$: of(86400),\n                collectionSkipDocuments$: of(500),\n                attachments: {},\n                options: {},\n                migrationStrategies: {},\n                autoMigrate: true,\n            },\n            cacheTimeInSeconds: 120\n        };\n        this.config = Object.assign(Object.assign(Object.assign({}, this.config), this._config), { restApiCreator: Object.assign(Object.assign({}, this.config.restApiCreator), this._config.restApiCreator), collectionApiCreator: Object.assign(Object.assign({}, this.config.collectionApiCreator), this._config.collectionApiCreator) });\n        this.restAPI = new RestAPI(this.config.restApiCreator);\n        this.collectionAPI = new CollectionAPI(this.config.collectionApiCreator);\n    }\n    downloadRetrieve(doc, tenant, url, params) {\n        if (!!doc && doc.method !== 'GET') {\n            return of(doc);\n        }\n        const currentTime = new Date().getTime();\n        if (!!doc && doc.time >= (currentTime - (this.config.cacheTimeInSeconds * 1000))) {\n            return of(doc);\n        }\n        return combineLatest([this.restAPI.get(url, params), this.collectionAPI.collection$]).pipe(switchMap(([res, col]) => col.atomicUpsert({\n            tenantUrl: this.collectionAPI.makeTenantUrl(tenant, url),\n            matchUrl: this.collectionAPI.makeTenantUrl(tenant, url),\n            data: res,\n            method: 'GET',\n            error: null,\n            time: new Date().getTime(),\n        })), catchError(() => of(doc)));\n    }\n    getReactive(tenant, url, params, wait = false) {\n        return this.collectionAPI.get(tenant, url).pipe(switchMap(doc => wait ?\n            this.downloadRetrieve(doc, tenant, url, params) :\n            this.downloadRetrieve(doc, tenant, url, params).pipe(startWith(null))), switchMap(() => this.collectionAPI.getReactive(tenant, url)), auditTime(1000 / 60));\n    }\n    get(tenant, url, params) {\n        return this.getReactive(tenant, url, params, true).pipe(take(1));\n    }\n    downloadList(res, tenant, url, params, indexedbUrl = (data, tenantUrl) => `${tenantUrl}/${data.id}`) {\n        const currentTime = new Date().getTime();\n        const limit = parseInt((params === null || params === void 0 ? void 0 : params.get('limit')) || '100');\n        const ids = res.results\n            .filter(v => v.method === 'PUT' || v.method === 'DELETE' || (v.method === 'GET' && v.time >= (currentTime - (this.config.cacheTimeInSeconds * 1000))))\n            .map(v => v.data.id);\n        if (ids.length === limit) {\n            return of({ next: res.next, previous: res.previous, results: [] });\n        }\n        params = params || new CustomHttpParams();\n        if (ids.length > 0) {\n            if (params.has('exclude:id.in')) {\n                params.delete('exclude:id.in');\n            }\n            params = params.append('exclude:id.in', ids.join(','));\n            params = params.set('limit', (limit - ids.length).toString());\n        }\n        return this.restAPI.list(url, params).pipe(catchError(() => of({ next: null, previous: null, results: [] })), switchMap(networkRes => this.collectionAPI.collection$.pipe(switchMap(col => {\n            const atomicWrites = networkRes.results\n                .map(data => ({\n                tenantUrl: indexedbUrl(data, this.collectionAPI.makeTenantUrl(tenant, url)),\n                matchUrl: indexedbUrl(data, this.collectionAPI.makeTenantUrl(tenant, url)),\n                data,\n                method: 'GET',\n                error: null,\n                time: new Date().getTime(),\n            }));\n            if (atomicWrites.length > 0) {\n                return from(col.bulkInsert(atomicWrites)).pipe(map(() => networkRes));\n            }\n            return of(networkRes);\n        }))));\n    }\n    listReactive(tenant, url, params, validQueryKeys = [], indexedbUrl = (data, tenantUrl) => `${tenantUrl}/${data.id}`, wait = false) {\n        return this.collectionAPI.list(tenant, url, params, validQueryKeys).pipe(switchMap(idbRes => wait ?\n            this.downloadList(idbRes, tenant, url, params, indexedbUrl) :\n            this.downloadList(idbRes, tenant, url, params, indexedbUrl).pipe(startWith({ next: null, previous: null, results: [] }))), switchMap((networkRes) => this.collectionAPI.listReactive(tenant, url, params, validQueryKeys).pipe(map(res => ({\n            next: (networkRes === null || networkRes === void 0 ? void 0 : networkRes.next) || res.next,\n            previous: (networkRes === null || networkRes === void 0 ? void 0 : networkRes.previous) || res.previous,\n            results: res.results\n        })))));\n    }\n    list(tenant, url, params, validQueryKeys = [], indexedbUrl = (data, tenantUrl) => `${tenantUrl}/${data.id}`) {\n        return this.listReactive(tenant, url, params, validQueryKeys, indexedbUrl, true).pipe(take(1));\n    }\n}\n\naddPouchPlugin(require('pouchdb-adapter-idb'));\nclass PwaDatabaseService {\n    constructor(_config) {\n        this._config = _config;\n    }\n    get db$() {\n        if (this._db$) {\n            return this._db$;\n        }\n        addRxPlugin(RxDBEncryptionPlugin);\n        addRxPlugin(RxDBLeaderElectionPlugin);\n        addRxPlugin(RxDBValidatePlugin);\n        addRxPlugin(RxDBMigrationPlugin);\n        const pouchAdapter = getRxStoragePouch('idb');\n        pouchAdapter.pouchSettings.revs_limit = 0,\n            pouchAdapter.pouchSettings.auto_compaction = true;\n        this._db$ = from(createRxDatabase(Object.assign({ name: 'pwadb', storage: pouchAdapter, password: 'ubT6LIL7ne2bdpze0V1DaeOGKKqYMWVF', multiInstance: true, eventReduce: true }, this._config.dbCreator))).pipe(switchMap((db) => from(db.waitForLeadership()).pipe(startWith(null), map(() => db))), shareReplay(1), first());\n        return this._db$;\n    }\n}\n\nclass ApiProgressService {\n    constructor(zone) {\n        this.zone = zone;\n        this.progress = new BehaviorSubject([]);\n        this.isProgressing$ = this.progress.asObservable().pipe(map(v => !!v.length), distinctUntilChanged(), auditTime(1000 / 60), enterZone(zone));\n    }\n    add() {\n        const newProgress = this.progress.value;\n        newProgress.push(true);\n        this.progress.next(newProgress);\n    }\n    remove() {\n        if (this.isProgressing()) {\n            const newProgress = this.progress.value;\n            newProgress.pop();\n            this.progress.next(newProgress);\n        }\n    }\n    isProgressing() {\n        return !!this.progress.value.length;\n    }\n}\nApiProgressService.ɵfac = function ApiProgressService_Factory(t) { return new (t || ApiProgressService)(i0.ɵɵinject(i0.NgZone)); };\nApiProgressService.ɵprov = i0.ɵɵdefineInjectable({ token: ApiProgressService, factory: ApiProgressService.ɵfac, providedIn: 'root' });\n(function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ApiProgressService, [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], function () { return [{ type: i0.NgZone }]; }, null);\n})();\n\nfunction flatten(arr, result = []) {\n    for (let i = 0, length = arr.length; i < length; i++) {\n        const value = arr[i];\n        if (Array.isArray(value)) {\n            flatten(value, result);\n        }\n        else {\n            result.push(value);\n        }\n    }\n    return result;\n}\n\nclass BaseDatabase {\n    constructor(__limit, __zone) {\n        this.__limit = __limit;\n        this.__zone = __zone;\n        this.data = [];\n        this.queueChange = new BehaviorSubject([]);\n        this._isLoadingChange = new BehaviorSubject(false);\n        this._httpParams = new CustomHttpParams();\n        this.isLoadingChange = this._isLoadingChange.asObservable().pipe(distinctUntilChanged(), enterZone(this.__zone));\n    }\n    get httpParams() { return this._httpParams; }\n    set httpParams(v) {\n        this._httpParams = v;\n        this.reset();\n    }\n    get isLoading() { return this._isLoadingChange.value; }\n    get offset() { return this.data.length; }\n    get isLoadable() { var _a; return !!((_a = this.lastRes) === null || _a === void 0 ? void 0 : _a.next); }\n    get limit() { return this.__limit; }\n    reset() {\n        this._httpParams = this.httpParams.delete('cursor');\n        this._httpParams = this.httpParams.set('offset', '0');\n        this._httpParams = this.httpParams.set('limit', this.limit.toString());\n        if (!this.httpParams.has('ordering')) {\n            this._httpParams = this.httpParams.set('ordering', '-created_at');\n        }\n    }\n    loadMore() {\n        var _a;\n        if ((_a = this.lastRes) === null || _a === void 0 ? void 0 : _a.next) {\n            const split = this.lastRes.next.split('?');\n            if (split.length > 1) {\n                split[1].split('&').forEach(q => {\n                    const queryParam = q.split('=');\n                    this._httpParams = this.httpParams.set(decodeURIComponent(queryParam[0]), decodeURIComponent(queryParam[1]));\n                });\n            }\n        }\n        this._httpParams = this.httpParams.set('offset', this.offset.toString());\n        this._httpParams = this.httpParams.set('limit', this.limit.toString());\n    }\n}\nclass Database extends BaseDatabase {\n    constructor(apiService, zone, _limit = 20) {\n        super(_limit, zone);\n        this.apiService = apiService;\n        this.zone = zone;\n        this._limit = _limit;\n        this.dataChange = this.queueChange.asObservable().pipe(tap(v => {\n            if (!v.length) {\n                this.reset();\n            }\n        }), filter$1(v => !!v.length), tap(() => this._isLoadingChange.next(true)), switchMap(v => combineLatest(v)), auditTime(1000 / 60), tap(res => this.lastRes = res.length > 0 ? res[res.length - 1] : null), map(res => flatten(res.map(v => v.results))), tap(v => this.data = v), tap(() => this._isLoadingChange.next(false)), shareReplay(1));\n    }\n    getView(httpParams) {\n        return this.apiService.fetch(httpParams).pipe(shareReplay(1));\n    }\n    reset() {\n        super.reset();\n        const view = this.getView(this.httpParams);\n        this.queueChange.next([view]);\n    }\n    loadMore() {\n        if (this.isLoading) {\n            return;\n        }\n        super.loadMore();\n        const view = this.getView(this.httpParams);\n        this.queueChange.next(flatten([this.queueChange.value, view]));\n    }\n}\nclass ReactiveDatabase extends BaseDatabase {\n    constructor(apiService, zone, _limit = 20) {\n        super(_limit, zone);\n        this.apiService = apiService;\n        this.zone = zone;\n        this._limit = _limit;\n        this.dataChange = this.queueChange.asObservable().pipe(tap(v => {\n            if (!v.length) {\n                this.reset();\n            }\n        }), filter$1(v => !!v.length), tap(() => this._isLoadingChange.next(true)), switchMap(v => combineLatest(v)), auditTime(1000 / 60), tap(res => this.lastRes = res.length > 0 ? res[res.length - 1] : null), map(res => flatten(res.map(v => v.results))), tap(v => this.data = v), tap(() => this._isLoadingChange.next(false)), shareReplay(1));\n    }\n    getView(httpParams) {\n        return this.apiService.fetchReactive(httpParams).pipe(shareReplay(1));\n    }\n    reset() {\n        super.reset();\n        const view = this.getView(this.httpParams);\n        this.queueChange.next([view]);\n    }\n    loadMore() {\n        if (this.isLoading) {\n            return;\n        }\n        super.loadMore();\n        const view = this.getView(this.httpParams);\n        this.queueChange.next(flatten([this.queueChange.value, view]));\n    }\n}\n\nclass TreeDatabase {\n    constructor(treeInfo) {\n        this.treeInfo = treeInfo;\n        this.databaseMap = new Map();\n        this.databaseKeyMap = new Map();\n        this.childTreeMap = new Map();\n        this._httpParams = new CustomHttpParams();\n        this.queueChange = new BehaviorSubject(true);\n        this.dataChange = this.queueChange.asObservable().pipe(switchMap(() => this.buildTree(this.treeInfo, null, this.httpParams)), shareReplay(1));\n    }\n    get httpParams() { return this._httpParams; }\n    set httpParams(v) {\n        this._httpParams = v;\n        this.reset();\n    }\n    buildTree(treeInfo, parentDoc = null, parentParams = new CustomHttpParams(), parentKey = null) {\n        const treeNodes = Object.keys(treeInfo).map(key => {\n            const db = treeInfo[key].getDatabase();\n            const currentDatabaseMapKey = parentKey && parentDoc ? `${parentKey}~${parentDoc.tenantUrl}--${key}` : key;\n            this.databaseKeyMap.set(currentDatabaseMapKey, db);\n            const possibleParamKeys = parentParams.keys().filter(pk => pk && pk.includes(`${key}--`));\n            let currentParams = new CustomHttpParams();\n            possibleParamKeys.forEach(pk => {\n                const paramName = pk.split(`${key}--`)[1];\n                if (!paramName.includes('--')) {\n                    currentParams = currentParams.set(paramName, parentParams.get(pk));\n                }\n            });\n            treeInfo[key].onCreationSetup ? treeInfo[key].onCreationSetup(parentDoc, db, currentParams) : db.httpParams = currentParams;\n            return db.dataChange.pipe(map(docs => {\n                const obsArr = docs.map(doc => {\n                    if (!this.databaseMap.has(doc)) {\n                        this.databaseMap.set(doc, db);\n                    }\n                    if (!this.childTreeMap.has(doc)) {\n                        if (treeInfo[key].isRecursive) {\n                            treeInfo[key].children[key] = treeInfo[key];\n                        }\n                        const childTree = this.buildTree(treeInfo[key].children, doc, parentParams, currentDatabaseMapKey).pipe(shareReplay(1));\n                        this.childTreeMap.set(doc, { item: doc, children: childTree });\n                    }\n                    return this.childTreeMap.get(doc);\n                });\n                return obsArr;\n            }));\n        });\n        return combineLatest(treeNodes).pipe(map(nodes => flatten(nodes)));\n    }\n    reset() {\n        this.databaseMap.clear();\n        this.databaseKeyMap.clear();\n        this.childTreeMap.clear();\n        this.queueChange.next(true);\n    }\n}\nclass DynamicFlatNode {\n    constructor(item, level = 1, expandable = false) {\n        this.item = item;\n        this.level = level;\n        this.expandable = expandable;\n    }\n}\nclass DynamicTreeFlattener {\n    constructor(transformFunction, getLevel, isExpandable, getChildren) {\n        this.transformFunction = transformFunction;\n        this.getLevel = getLevel;\n        this.isExpandable = isExpandable;\n        this.getChildren = getChildren;\n        this.flatNodeMap = new Map();\n        this.structuredNodeMap = new Map();\n        this.parentNodeMap = new Map();\n    }\n    _flattenNode(node, level) {\n        if (!this.flatNodeMap.has(node)) {\n            const flatNode = this.transformFunction(node, level);\n            this.flatNodeMap.set(node, flatNode);\n            this.structuredNodeMap.set(flatNode, node);\n        }\n        return this.flatNodeMap.get(node);\n    }\n    insertChildrenFlatNodes(parentNode, children, resultNodes) {\n        const index = resultNodes.indexOf(parentNode);\n        resultNodes.splice(index + 1, 0, ...children);\n        children.filter(c => !this.parentNodeMap.has(c)).forEach(c => this.parentNodeMap.set(c, parentNode));\n        return resultNodes;\n    }\n    removeChildrenFlatNodes(parentNode, resultNodes) {\n        const index = resultNodes.indexOf(parentNode);\n        let count = 0;\n        for (let i = index + 1; i < resultNodes.length && this.getLevel(resultNodes[i]) > this.getLevel(parentNode); i++, count++) { }\n        const children = resultNodes.splice(index + 1, count);\n        children.filter(c => this.parentNodeMap.has(c)).forEach(c => this.parentNodeMap.delete(c));\n        return resultNodes;\n    }\n    addChildrenFlatNode(parentFlatNode, resultNodes) {\n        const structuredNode = this.structuredNodeMap.get(parentFlatNode);\n        const structuredChildrenNodes = this.getChildren(structuredNode);\n        if (structuredChildrenNodes) {\n            if (Array.isArray(structuredChildrenNodes)) {\n                const flatChildren = structuredChildrenNodes.map(s => this._flattenNode(s, this.getLevel(parentFlatNode) + 1));\n                return of(this.insertChildrenFlatNodes(parentFlatNode, flatChildren, resultNodes));\n            }\n            else {\n                return structuredChildrenNodes.pipe(map(children => children.map(s => this._flattenNode(s, this.getLevel(parentFlatNode) + 1))), map(flatChildren => {\n                    resultNodes = this.removeChildrenFlatNodes(parentFlatNode, resultNodes);\n                    return this.insertChildrenFlatNodes(parentFlatNode, flatChildren, resultNodes);\n                }));\n            }\n        }\n        return of(resultNodes);\n    }\n    flattenNodes(structuredData) {\n        return structuredData.map(node => this._flattenNode(node, 0));\n    }\n}\nclass DynamicFlatTreeDataSource {\n    constructor(_treeControl, _treeFlattener, initialData) {\n        this._treeControl = _treeControl;\n        this._treeFlattener = _treeFlattener;\n        this._flattenedData = new BehaviorSubject([]);\n        this._data = new BehaviorSubject([]);\n        this.subs = new Subscription();\n        if (initialData) {\n            this.data = initialData;\n        }\n    }\n    get data() { return this._data.value; }\n    set data(value) {\n        this._data.next(value);\n        const flattenedData = this._treeFlattener.flattenNodes(this.data);\n        this._treeControl.expansionModel.clear();\n        this._treeControl.dataNodes = flattenedData;\n        this.flattenedData = flattenedData;\n    }\n    mergeData(value) {\n        this._data.next(value);\n        const flattenedData = this._treeFlattener.flattenNodes(this.data);\n        const mergeObj = {};\n        this.flattenedData.concat(flattenedData).forEach(f => mergeObj[f.id] = f);\n        const mergedFlattenedData = Object.values(mergeObj);\n        this._treeControl.dataNodes = mergedFlattenedData;\n        this.flattenedData = mergedFlattenedData;\n    }\n    get flattenedData() { return this._flattenedData.value; }\n    set flattenedData(v) { this._flattenedData.next(v); }\n    toggleNode(flatNode, expand) {\n        if (expand) {\n            if (this._treeFlattener.isExpandable(flatNode)) {\n                return this._treeFlattener.addChildrenFlatNode(flatNode, this.flattenedData);\n            }\n            return this._flattenedData.asObservable();\n        }\n        else {\n            return of(this._treeFlattener.removeChildrenFlatNodes(flatNode, this.flattenedData));\n        }\n    }\n    handleTreeControl(change) {\n        if (change.added) {\n            const obsArray = change.added.map(node => this.toggleNode(node, true));\n            return combineLatest(obsArray).pipe(map((o) => o.length > 0 ? o[obsArray.length - 1] : []));\n        }\n        if (change.removed) {\n            const obsArray = change.removed.slice().reverse().map(node => this.toggleNode(node, false));\n            return combineLatest(obsArray).pipe(map((o) => o.length > 0 ? o[obsArray.length - 1] : []));\n        }\n    }\n    connect(collectionViewer) {\n        const changeObs = this._treeControl.expansionModel.changed.pipe(filter$1(change => { var _a, _b; return !!((_a = change.added) === null || _a === void 0 ? void 0 : _a.length) || !!((_b = change.removed) === null || _b === void 0 ? void 0 : _b.length); }), mergeMap(change => this.handleTreeControl(change)), auditTime(1000 / 60));\n        const subs = changeObs.subscribe((v) => {\n            this._treeControl.dataNodes = v;\n            this.flattenedData = v;\n        });\n        this.subs.add(subs);\n        return merge(collectionViewer.viewChange, this._flattenedData.asObservable()).pipe(map(() => this.flattenedData));\n    }\n    disconnect(collectionViewer) {\n        this.subs.unsubscribe();\n    }\n}\n\nclass SyncCollectionService {\n    constructor(_config) {\n        this._config = _config;\n        this.config = {\n            name: 'no_name_sync_collection',\n            db$: of(),\n            attachments: {},\n            options: {},\n            migrationStrategies: {},\n            autoMigrate: true,\n            ngZone: null,\n            httpClient: null,\n        };\n        this.config = Object.assign(Object.assign({}, this.config), this._config);\n        this.retryChange = new BehaviorSubject(true);\n        this.storedCollections = this.collection$.pipe(switchMap(col => col.find().$), map(docs => docs.map(d => d.toJSON())), map(docTypes => {\n            const databasesSchema = {};\n            docTypes.forEach(d => {\n                const key = d.databaseOptions;\n                key in databasesSchema ? databasesSchema[key].push(d) : databasesSchema[key] = [d];\n            });\n            const databasesMap = [];\n            Object.keys(databasesSchema).forEach(schema => {\n                const pwaDatabaseService = new PwaDatabaseService({ dbCreator: Object.assign(Object.assign({}, JSON.parse(schema)), { ignoreDuplicate: true }) });\n                databasesMap.push({ database: pwaDatabaseService.db$, collectionInfo: databasesSchema[schema] });\n            });\n            return databasesMap;\n        }), switchMap(databasesMap => combineLatest(databasesMap.map(m => {\n            return m.database.pipe(switchMap(db => {\n                const collectionInfoKeyValue = m.collectionInfo.reduce((cur, acc) => {\n                    acc[cur.collectionName] = cur;\n                    return acc;\n                }, {});\n                const collections = {};\n                m.collectionInfo.forEach(i => {\n                    const collectionOptions = JSON.parse(i.collectionOptions);\n                    collections[i.collectionName] = getCollectionCreator(i.collectionName, pwaCollectionMethods, pwaDocMethods, collectionOptions.attachments, collectionOptions.options, collectionOptions.migrationStrategies, collectionOptions.autoMigrate);\n                });\n                return from(db.addCollections(collections)).pipe(map(v => Object.keys(v).map(k => (Object.assign({ collection: v[k] }, collectionInfoKeyValue[k])))));\n            }));\n        }))), map(v => flatten(v)), tap((v) => {\n            v.forEach(docType => {\n                docType.collection.preSave((plainData, rxDocument) => {\n                    plainData.createdAt = plainData.createdAt || new Date().getTime();\n                    plainData.updatedAt = new Date().getTime();\n                }, false);\n            });\n        }), shareReplay(1));\n    }\n    get collection$() {\n        if (this._collection$) {\n            return this._collection$;\n        }\n        const collectionSchema = {};\n        collectionSchema[this.config.name] = getSynchroniseCollectionCreator(this.config.name, synchroniseCollectionMethods, synchroniseDocMethods, this.config.attachments, this.config.options, this.config.migrationStrategies, this.config.autoMigrate);\n        this._collection$ = this.config.db$.pipe(switchMap(db => from(db.addCollections(collectionSchema))), map(collections => collections[this.config.name]), shareReplay(1), first());\n        return this._collection$;\n    }\n    addSynchroniseDocument(data) {\n        return this.collection$.pipe(switchMap(col => col.atomicUpsert(data)));\n    }\n    startSync() {\n        this.retryChange.next(true);\n    }\n    stopSync() {\n        this.retryChange.next(false);\n    }\n    unsynchronised(tenant, order = 'asc') {\n        return this.storedCollections.pipe(switchMap((collectionsInfo) => {\n            const query = {\n                selector: {\n                    matchUrl: { $regex: new RegExp(`^${tenant}.*`) },\n                    method: { $ne: 'GET' }\n                }\n            };\n            const sortedDocs$ = collectionsInfo.map(k => {\n                return from(k.collection.find(query).$.pipe(auditTime(1000 / 60)));\n            });\n            return combineLatest(sortedDocs$);\n        }), map(sortedDocs => flatten(sortedDocs)), map((sortedDocs) => sortedDocs.sort((a, b) => order === 'asc' ? a.time - b.time : b.time - a.time)), enterZone(this.config.ngZone));\n    }\n    synchronise(tenant) {\n        const pop = this.unsynchronised(tenant, 'asc').pipe(filter$1(sortedDocs => sortedDocs.length > 0), map(sortedDocs => sortedDocs[0]));\n        const hit = pop.pipe(concatMap(doc => {\n            if (doc.method === 'POST') {\n                const url = doc.tenantUrl.split('____')[1].split('/');\n                url.splice(url.length - 1, 1);\n                let formData;\n                if (doc.fileFields.length) {\n                    formData = createFormData(doc.toJSON().data);\n                    doc.fileFields.forEach(k => {\n                        formData.delete(k.fileField);\n                        formData.delete(k.fileNameField);\n                        formData.delete(k.fileType);\n                        if (k.fileKeyField && k.fileField && k.fileType)\n                            formData.append(k.fileKeyField, new File([new Uint8Array(JSON.parse(doc.data[k.fileField])).buffer], k.fileNameField || 'Unknown', { type: k.fileType }));\n                    });\n                }\n                else {\n                    formData = doc.toJSON().data;\n                }\n                return this.config.httpClient.post(url.join('/'), formData).pipe(switchMap(res => doc.atomicPatch({\n                    method: 'GET',\n                    data: res,\n                    error: null,\n                    time: new Date().getTime()\n                })), catchError(err => {\n                    return from(doc.atomicPatch({ error: JSON.stringify(err) })).pipe(finalize(() => this.retryChange.next(false)));\n                }));\n            }\n            else if (doc.method === 'PUT') {\n                let formData;\n                if (doc.fileFields.length) {\n                    formData = createFormData(doc.toJSON().data);\n                    doc.fileFields.forEach(k => {\n                        formData.delete(k.fileField);\n                        formData.delete(k.fileNameField);\n                        formData.delete(k.fileType);\n                        if (k.fileKeyField && k.fileField && k.fileType)\n                            formData.append(k.fileKeyField, new File([new Uint8Array(JSON.parse(doc.data[k.fileField])).buffer], k.fileNameField || 'Unknown', { type: k.fileType }));\n                    });\n                }\n                else {\n                    formData = doc.toJSON().data;\n                }\n                return this.config.httpClient.put(doc.tenantUrl.split('____')[1], formData).pipe(switchMap(res => doc.atomicPatch({\n                    method: 'GET',\n                    data: res,\n                    error: null,\n                    time: new Date().getTime()\n                })), catchError(err => {\n                    return from(doc.atomicPatch({ error: JSON.stringify(err) })).pipe(finalize(() => this.retryChange.next(false)));\n                }));\n            }\n            else if (doc.method === 'DELETE') {\n                return this.config.httpClient.delete(doc.tenantUrl.split('____')[1]).pipe(switchMap(() => doc.remove()), catchError(err => {\n                    return from(doc.atomicPatch({ error: JSON.stringify(err) })).pipe(finalize(() => this.retryChange.next(false)));\n                }));\n            }\n            return throwError(`Document doesn\\'t have valid method. Document: ${JSON.stringify(doc === null || doc === void 0 ? void 0 : doc.toJSON())}`);\n        }));\n        return this.retryChange.asObservable().pipe(switchMap(trigger => trigger ? hit : of()));\n    }\n    evict() {\n        return this.storedCollections.pipe(switchMap(collectionInfo => {\n            const evicts = collectionInfo.map(k => {\n                const cacheAllowedAge = new Date().getTime() - (k.collectionEvictTime * 1000);\n                return k.collection.insert$.pipe(switchMap(() => k.collection.find({ selector: { $and: [{ method: { $eq: 'GET' } }, { time: { $lt: cacheAllowedAge } }] } }).remove()));\n            });\n            return combineLatest(evicts);\n        }));\n    }\n    skipTrim() {\n        return this.storedCollections.pipe(switchMap((collectionInfo) => {\n            const skipTrims = collectionInfo.map(k => {\n                return k.collection.insert$.pipe(switchMap(() => k.collection.find({ selector: { method: { $eq: 'GET' } }, sort: [{ time: 'desc' }], skip: k.collectionSkipDocuments }).remove()));\n            });\n            return combineLatest(skipTrims);\n        }));\n    }\n    createNew(doc) {\n        if (!!doc && doc.method !== 'GET' && doc.method !== 'POST') {\n            return from(doc.atomicPatch({ method: 'POST' }));\n        }\n        return throwError(`Cannot duplicate this document. Document: ${JSON.stringify((doc === null || doc === void 0 ? void 0 : doc.toJSON()) || {})}`);\n    }\n    deleteConflict(doc) {\n        if (!!doc && doc.method !== 'GET') {\n            return from(doc.remove());\n        }\n        return throwError(`Cannot delete this document. Document: ${JSON.stringify((doc === null || doc === void 0 ? void 0 : doc.toJSON()) || {})}`);\n    }\n}\nfunction createFormData(object, form, namespace) {\n    let formData = form || new FormData();\n    for (let propertyName in object) {\n        const formKey = namespace ? `${namespace}.${propertyName}` : propertyName;\n        if (object[propertyName] instanceof Date) {\n            formData.append(formKey, object[propertyName].toISOString());\n        }\n        else if (object[propertyName] instanceof Array) {\n            object[propertyName].forEach((element, index) => {\n                const tempFormKey = `${formKey}-${index}`;\n                if (typeof element === 'object') {\n                    createFormData(element, formData, tempFormKey);\n                }\n                else {\n                    formData.append(tempFormKey, element.toString());\n                }\n            });\n        }\n        else if (typeof object[propertyName] === 'object' && !(object[propertyName] instanceof File) && object[propertyName] !== null && object[propertyName] !== undefined) {\n            createFormData(object[propertyName], formData, formKey);\n        }\n        else {\n            formData.append(formKey, object[propertyName] === null || object[propertyName] === undefined ? '' : object[propertyName].toString());\n        }\n    }\n    return formData;\n}\n\naddPouchPlugin(require('pouchdb-adapter-idb'));\nclass SyncDatabaseService {\n    constructor(_config) {\n        this._config = _config;\n    }\n    get db$() {\n        if (this._db$) {\n            return this._db$;\n        }\n        addRxPlugin(RxDBEncryptionPlugin);\n        addRxPlugin(RxDBLeaderElectionPlugin);\n        addRxPlugin(RxDBValidatePlugin);\n        const pouchAdapter = getRxStoragePouch('idb');\n        pouchAdapter.pouchSettings.revs_limit = 0,\n            pouchAdapter.pouchSettings.auto_compaction = true;\n        this._db$ = from(createRxDatabase(Object.assign({ name: 'synchronise/pwadb', storage: pouchAdapter, password: 'ubT6LIL7ne2bdpze0V1DaeOGKKqYMWVF', multiInstance: true, eventReduce: true }, this._config.dbCreator))).pipe(switchMap((db) => from(db.waitForLeadership()).pipe(startWith(null), map(() => db))), shareReplay(1), first());\n        return this._db$;\n    }\n}\n\nexport { ApiProgressService, BaseDatabase, CollectionAPI, CustomEncoder, CustomHttpParams, Database, DynamicFlatNode, DynamicFlatTreeDataSource, DynamicTreeFlattener, PwaCollectionAPI, PwaDatabaseService, ReactiveDatabase, RestAPI, SyncCollectionService, SyncDatabaseService, TreeDatabase, contains, createFormData, distinct, endswith, enterZone, eq, exact, exclude, filter, flatten, getCollectionCreator, getQuery, getSchema, getSynchroniseCollectionCreator, getSynchroniseSchema, gt, gte, icontains, iexact, isnull, lt, lte, orderBy, parseBoolean, parseDate, parseNumber, pwaCollectionMethods, pwaDocMethods, queryFilter, range, startswith, synchroniseCollectionMethods, synchroniseDocMethods };\n//# sourceMappingURL=advance-tools-pwadb-lib.mjs.map\n","map":{"version":3,"file":"advance-tools-pwadb-lib.mjs","sources":["../../../projects/pwadb-lib/src/lib/definitions/document.ts","../../../projects/pwadb-lib/src/lib/definitions/collection.ts","../../../projects/pwadb-lib/src/lib/definitions/synchronise-document.ts","../../../projects/pwadb-lib/src/lib/definitions/synchronise-collection.ts","../../../projects/pwadb-lib/src/lib/resources/customParams.resource.ts","../../../projects/pwadb-lib/src/lib/resources/filters.resource.ts","../../../projects/pwadb-lib/src/lib/resources/operators.resource.ts","../../../projects/pwadb-lib/src/lib/resources/collection.resource.ts","../../../projects/pwadb-lib/src/lib/resources/database.resource.ts","../../../projects/pwadb-lib/src/lib/resources/apiProgress.resource.ts","../../../projects/pwadb-lib/src/lib/resources/misc.resource.ts","../../../projects/pwadb-lib/src/lib/resources/table.resource.ts","../../../projects/pwadb-lib/src/lib/resources/tree.resource.ts","../../../projects/pwadb-lib/src/lib/resources/synchronise-collection.resource.ts","../../../projects/pwadb-lib/src/lib/resources/synchronise-database.resource.ts"],"sourcesContent":["import { RxJsonSchema, RxDocument } from 'rxdb';\n\nexport type Method = 'GET' | 'POST' | 'PUT' | 'DELETE';\n\nexport type Datatype = {\n    id: string;\n};\n\nexport interface FileConfig {\n    fileField: string;\n    fileNameField: string;\n    fileType: string;\n    fileKeyField: string;\n}\n\nexport type PwaDocType<T extends Datatype> = {\n    tenantUrl: string;\n    matchUrl: string;\n    method: Method;\n    data: T | null;\n    time: number;\n    error: string | null;\n    fileFields: FileConfig[];\n    createdAt: number;\n    updatedAt: number;\n};\n\nexport type PwaDocMethods = {};\n\nexport type PwaDocument<T extends Datatype> = RxDocument<PwaDocType<T>, PwaDocMethods>;\n\nexport const getSchema: (name: string) => RxJsonSchema<PwaDocType<any>> = (name: string) => ({\n    title: name + '_store',\n    description: `Store ${name} types of data in the collection`,\n    keyCompression: false,\n    version: 4,\n    type: 'object',\n    primaryKey: 'tenantUrl',\n    properties: {\n        tenantUrl: {\n            type: 'string',\n            primary: true,\n        },\n        matchUrl: {\n            type: 'string',\n        },\n        method: {\n            type: 'string',\n            enum: ['GET', 'POST', 'PUT', 'DELETE'],\n        },\n        data: {\n            type: ['object', 'null'],\n        },\n        time: {\n            type: 'integer',\n        },\n        error: {\n            type: ['string', 'null'],\n        },\n        fileFields: {\n            type: ['array'],\n            default: [],\n            items: {\n                type: ['object'],\n                properties: {\n                    fileField: {\n                        type: ['string']\n                    },\n                    fileNameField: {\n                        type: ['string']\n                    },\n                    fileType: {\n                        type: ['string']\n                    },\n                    fileKeyField: {\n                        type: ['string']\n                    }\n                }\n            }\n        },\n        createdAt: {\n            type: 'integer',\n        },\n        updatedAt: {\n            type: 'integer'\n        }\n    },\n    encrypted: [\n        'data',\n        'fileFields'\n    ],\n});\n\nexport const pwaDocMethods: PwaDocMethods = {};\n","import { PwaDocType, PwaDocMethods, Datatype, getSchema, PwaDocument } from './document';\nimport { RxCollection, RxCollectionCreator } from 'rxdb';\n\nexport type PwaCollectionMethods = {};\n\nexport type PwaCollection<T extends Datatype> = RxCollection<PwaDocType<T>, PwaDocMethods, PwaCollectionMethods>;\n\nexport const getCollectionCreator = (\n    name: string,\n    collectionMethods: PwaCollectionMethods,\n    documentMethods: PwaDocMethods,\n    attachments = {},\n    options = {},\n    migrationStrategies = {},\n    autoMigrate = true,\n) => ({\n        name,\n        schema: getSchema(name),\n        statics: collectionMethods, // (optional) // ORM-functions for this collection\n        methods: documentMethods, // (optional) ORM-functions for documents\n        attachments, // (optional) ORM-functions for attachments\n        options, // (optional) Custom paramters that might be used in plugins\n        migrationStrategies: {\n            // 1 means, this transforms data from version 0 to version 1\n            1: (oldDoc: PwaDocType<any>) => {\n\n                oldDoc.createdAt = new Date().getTime();\n                oldDoc.updatedAt = new Date().getTime();\n\n                return oldDoc;\n            },\n            2: (oldDoc: PwaDocType<any>) => {\n\n                oldDoc.fileFields = [];\n\n                return oldDoc;\n            },\n            3: (oldDoc: PwaDocType<any>) => {\n\n                oldDoc.fileFields = [];\n\n                return oldDoc;\n            },\n            4: (oldDoc: PwaDocType<any>) => {\n\n                oldDoc.fileFields = [];\n\n                return oldDoc;\n            },\n            ...migrationStrategies\n        }, // (optional)\n        autoMigrate, // (optional)\n} as RxCollectionCreator);\n\nexport const pwaCollectionMethods: PwaCollectionMethods = {};\n\n///////////////////////\n// interfaces\n///////////////////////\n\nexport interface ListResponse<T extends Datatype> {\n    next: string;\n    previous: string;\n    results: T[];\n}\n\nexport interface CollectionListResponse<T extends Datatype> {\n    next: string;\n    previous: string;\n    results: PwaDocument<T>[];\n    count?: number;\n}\n\nexport interface PwaListResponse<T extends Datatype> {\n    next: string;\n    previous: string;\n    results: PwaDocument<T>[];\n}\n","import { RxDocument, RxJsonSchema } from 'rxdb';\nimport { PwaDocument } from './document';\n\nexport type SynchroniseDocType = {\n    id: string;\n    databaseOptions: string,\n    collectionName: string,\n    collectionOptions: string,\n    collectionEvictTime: number,\n    collectionSkipDocuments: number\n};\n\nexport type SynchroniseDocMethods = {};\n\nexport type SynchroniseDocument = RxDocument<SynchroniseDocType>;\n\nexport const getSynchroniseSchema: () => RxJsonSchema<SynchroniseDocType> = () => ({\n    title: 'synchronise_store',\n    description: `Stores database & collectionNames of data in the collection`,\n    keyCompression: false,\n    version: 0,\n    type: 'object',\n    primaryKey: 'id',\n    properties: {\n        id: {\n            type: 'string',\n            primary: true,\n        },\n        databaseOptions: {\n            type: 'string',\n        },\n        collectionName: {\n            type: 'string'\n        },\n        collectionOptions: {\n            type: 'string',\n        },\n        collectionEvictTime: {\n            type: 'integer'\n        },\n        collectionSkipDocuments: {\n            type: 'integer'\n        },\n        collectionReqTitleFieldName: {\n            type: 'string'\n        },\n        collectionReqSubTitleFieldName: {\n            type: ['string', 'null']\n        },\n        collectionReqIconFieldName: {\n            type: ['string', 'null']\n        }\n    },\n    encrypted: [\n        'databaseOptions',\n        'collectionName',\n        'collectionOptions',\n        'collectionEvictTime',\n        'collectionSkipDocuments',\n        'collectionReqTitleFieldName',\n        'collectionReqSubTitleFieldName',\n        'collectionReqIconFieldName',\n    ],\n});\n\nexport const synchroniseDocMethods: SynchroniseDocMethods = {};\n\n","import { RxCollection, RxCollectionCreator } from 'rxdb';\nimport { getSynchroniseSchema, SynchroniseDocMethods, SynchroniseDocType } from './synchronise-document';\n\nexport type SynchroniseCollectionMethods = {};\n\nexport type SynchroniseCollection = RxCollection<SynchroniseDocType, SynchroniseDocMethods, SynchroniseCollectionMethods>;\n\nexport const getSynchroniseCollectionCreator = (\n    name: string,\n    collectionMethods: SynchroniseCollectionMethods,\n    documentMethods: SynchroniseDocMethods,\n    attachments = {},\n    options = {},\n    migrationStrategies = {},\n    autoMigrate = true,\n) => ({\n        name,\n        schema: getSynchroniseSchema(),\n        pouchSettings: {\n            revs_limit: 0,\n            auto_compaction: true,\n        }, // (optional)\n        statics: collectionMethods, // (optional) // ORM-functions for this collection\n        methods: documentMethods, // (optional) ORM-functions for documents\n        attachments, // (optional) ORM-functions for attachments\n        options, // (optional) Custom paramters that might be used in plugins\n        migrationStrategies, // (optional)\n        autoMigrate, // (optional)\n} as RxCollectionCreator);\n\nexport const synchroniseCollectionMethods: SynchroniseCollectionMethods = {};\n","import { HttpParameterCodec, HttpParams, HttpParamsOptions } from \"@angular/common/http\";\n\nexport class CustomEncoder implements HttpParameterCodec {\n    encodeKey(key: string): string {\n        return encodeURIComponent(key);\n    }\n\n    encodeValue(value: string): string {\n        return encodeURIComponent(value);\n    }\n\n    decodeKey(key: string): string {\n        return decodeURIComponent(key);\n    }\n\n    decodeValue(value: string): string {\n        return decodeURIComponent(value);\n    }\n}\n\nexport class CustomHttpParams extends HttpParams {\n\n    constructor(options?: HttpParamsOptions) {\n\n        options = {...(options || {}), encoder: new CustomEncoder()};\n\n        super(options)\n    }\n}\n","import { PwaDocument } from '../definitions/document';\nimport { HttpParams } from '@angular/common/http';\n\n////////////////\n// Types\n////////////////\n// tslint:disable-next-line: max-line-length\nexport type Lookup = 'gte' | 'lte' | 'gt' | 'lt' | 'eq' | 'startswith' | 'endswith' | 'range' | 'isnull' | 'iexact' | 'exact' | 'icontains' | 'contains' | 'in';\n\nexport type Query = 'filter' | 'distinct' | 'exclude' | 'ordering' | 'only';\n\nexport type FieldDataType = string | number | boolean | null;\n\n////////////////\n// Parsers\n////////////////\nexport function parseNumber(fieldValue: FieldDataType, inputValue: string): null | {[key: string]: number} {\n\n    const parsedFieldValue = Number(fieldValue?.toString() || '');\n\n    const parsedInputValue = Number(inputValue?.toString() || '');\n\n    return isNaN(parsedFieldValue) && isNaN(parsedInputValue) ? null : {parsedFieldValue, parsedInputValue};\n}\n\nexport function parseDate(fieldValue: FieldDataType, inputValue: string): null | {[key: string]: number} {\n\n    const parsedFieldValue = Date.parse(fieldValue?.toString() || '');\n\n    const parsedInputValue = Date.parse(inputValue?.toString() || '');\n\n    return isNaN(parsedFieldValue) && isNaN(parsedInputValue) ? null : {parsedFieldValue, parsedInputValue};\n}\n\nexport function parseBoolean(fieldValue: FieldDataType, inputValue: string): null | {[key: string]: boolean} {\n\n    // tslint:disable-next-line: max-line-length\n    const parsedFieldValue = fieldValue?.toString().toLowerCase() === 'true' ? true : fieldValue?.toString().toLowerCase() === 'false' ? false : null;\n\n    // tslint:disable-next-line: max-line-length\n    const parsedInputValue = inputValue?.toString().toLowerCase() === 'true' ? true : inputValue?.toString().toLowerCase() === 'false' ? false : null;\n\n    return parsedFieldValue === null || parsedInputValue === null ? null : {parsedFieldValue, parsedInputValue};\n}\n\n///////////////////////////////////////////////\n// Lookup Filters (num, date, string, boolean)\n///////////////////////////////////////////////\n\n// tslint:disable-next-line: max-line-length\nexport const eq: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue === isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue === isNumber.parsedInputValue; }\n\n    const isBoolean = parseBoolean(v.data[field] as FieldDataType, inputValue);\n\n    if (isBoolean) { return isBoolean.parsedFieldValue === isBoolean.parsedInputValue; }\n\n    return v.data[field] === inputValue;\n};\n\n///////////////////////////////////////////////\n// Lookup Filters (num, date)\n///////////////////////////////////////////////\n\n// tslint:disable-next-line: max-line-length\nexport const gte: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue >= isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue >= isNumber.parsedInputValue; }\n\n    return v.data[field] >= inputValue;\n};\n\n// tslint:disable-next-line: max-line-length\nexport const lte: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue <= isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue <= isNumber.parsedInputValue; }\n\n    return v.data[field] <= inputValue;\n};\n\n// tslint:disable-next-line: max-line-length\nexport const gt: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue > isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue > isNumber.parsedInputValue; }\n\n    return v.data[field] > inputValue;\n};\n\n// tslint:disable-next-line: max-line-length\nexport const lt: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const isDate = parseDate(v.data[field] as FieldDataType, inputValue);\n\n    if (isDate) { return isDate.parsedFieldValue < isDate.parsedInputValue; }\n\n    const isNumber = parseNumber(v.data[field] as FieldDataType, inputValue);\n\n    if (isNumber) { return isNumber.parsedFieldValue < isNumber.parsedInputValue; }\n\n    return v.data[field] < inputValue;\n};\n\n// tslint:disable-next-line: max-line-length\nexport const range: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => {\n\n    const values = inputValue.toString().split(',');\n\n    const isDate1 = parseDate(v.data[field] as FieldDataType, values[0]);\n\n    const isDate2 = parseDate(v.data[field] as FieldDataType, values[1]);\n\n    // tslint:disable-next-line: max-line-length\n    if (isDate1 && isDate2) { return isDate1.parsedFieldValue >= isDate1.parsedInputValue && isDate2.parsedFieldValue < isDate2.parsedInputValue; }\n\n    const isNumber1 = parseNumber(v.data[field] as FieldDataType, values[0]);\n\n    const isNumber2 = parseNumber(v.data[field] as FieldDataType, values[1]);\n\n    // tslint:disable-next-line: max-line-length\n    if (isNumber1 && isNumber2) { return isNumber1.parsedFieldValue >= isNumber1.parsedInputValue && isNumber2.parsedFieldValue < isNumber2.parsedInputValue; }\n\n    return v.data[field] >= values[0] && v.data[field] < values[1];\n};\n\n///////////////////////////////////////////////\n// Lookup Filters (string)\n///////////////////////////////////////////////\n\n// tslint:disable-next-line: max-line-length\nexport const startswith: (v: PwaDocument<any>, field: string, inputValue: string) => boolean = (v: PwaDocument<any>, field: string, inputValue: string) => (v.data[field] as FieldDataType)?.toString().startsWith(inputValue);\n\n// tslint:disable-next-line: max-line-length\nexport const endswith: (v: PwaDocument<any>, field: string, inputValue: string) => boolean   = (v: PwaDocument<any>, field: string, inputValue: string) => (v.data[field] as FieldDataType)?.toString().endsWith(inputValue);\n\n// tslint:disable-next-line: max-line-length\nexport const iexact: (v: PwaDocument<any>, field: string, inputValue: string) => boolean     = (v: PwaDocument<any>, field: string, inputValue: string) => !!(v.data[field] as FieldDataType)?.toString().match(new RegExp(`^${inputValue}$`, 'i'));\n\n// tslint:disable-next-line: max-line-length\nexport const exact: (v: PwaDocument<any>, field: string, inputValue: string) => boolean      = (v: PwaDocument<any>, field: string, inputValue: string) => !!(v.data[field] as FieldDataType)?.toString().match(new RegExp(`^${inputValue}$`));\n\n// tslint:disable-next-line: max-line-length\nexport const icontains: (v: PwaDocument<any>, field: string, inputValue: string) => boolean  = (v: PwaDocument<any>, field: string, inputValue: string) => (v.data[field] as FieldDataType)?.toString().toLowerCase().includes(inputValue?.toLowerCase() || '');\n\n// tslint:disable-next-line: max-line-length\nexport const contains: (v: PwaDocument<any>, field: string, inputValue: string) => boolean   = (v: PwaDocument<any>, field: string, inputValue: string) => (v.data[field] as FieldDataType)?.toString().includes(inputValue);\n\n///////////////////////////////////////////////\n// Lookup Filters (boolean)\n///////////////////////////////////////////////\n// tslint:disable-next-line: max-line-length\nexport const isnull: (v: PwaDocument<any>, field: string, inputValue: string) => boolean     = (v: PwaDocument<any>, field: string, inputValue: string) => inputValue?.toLowerCase() === 'true' ? v.data[field] === null : v.data[field] !== null;\n\n\nexport function getQuery(key: string, value: string): {queryType: Query, fields: string[], lookup?: Lookup, inputValue?: string} {\n\n    if (key.includes('distinct')) {\n\n        return {queryType: 'distinct', fields: value.split(',')};\n\n    } else if (key.includes('only')) {\n\n        return {queryType: 'only', fields: value.split(',')};\n\n    } else if (key.includes('ordering')) {\n\n        return {queryType: 'ordering', fields: value.split(',')};\n\n    } else if (key.includes('exclude')) {\n\n        const fieldAndLookup = key.split(':')[1].split('.');\n\n        // tslint:disable-next-line: max-line-length\n        return {queryType: 'exclude', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] as Lookup : 'eq', inputValue: value};\n\n    } else if (key.includes('filter')) {\n\n        const fieldAndLookup = key.split(':')[1].split('.');\n\n        // tslint:disable-next-line: max-line-length\n        return {queryType: 'filter', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] as Lookup : 'eq', inputValue: value};\n\n    } else {\n\n        const fieldAndLookup = key.split('.');\n\n        // tslint:disable-next-line: max-line-length\n        return {queryType: 'filter', fields: [fieldAndLookup[0]], lookup: fieldAndLookup.length > 1 ? fieldAndLookup[1] as Lookup : 'eq', inputValue: value};\n    }\n\n}\n\n\nexport function queryFilter(validQueryKeys: string[], params: HttpParams, docs: PwaDocument<any>[]): PwaDocument<any>[] {\n\n    if (params) {\n\n        const keys = params.keys();\n\n        //////////////\n        // Filters (1)\n        //////////////\n        keys.forEach(k => {\n\n            if (validQueryKeys.indexOf(k) > -1) {\n\n                const query = getQuery(k, params.getAll(k).join(','));\n\n                if (query.queryType === 'filter') { docs = filter(query.fields[0], query.inputValue, docs, query.lookup); }\n            }\n        });\n\n        ///////////////\n        // Exclude (2)\n        ///////////////\n\n        keys.forEach(k => {\n\n            if (validQueryKeys.indexOf(k) > -1) {\n\n                const query = getQuery(k, params.getAll(k).join(','));\n\n                if (query.queryType === 'exclude') { docs = exclude(query.fields[0], query.inputValue, docs, query.lookup); }\n            }\n        });\n\n        ////////////////\n        // Order By (3)\n        ////////////////\n\n        keys.forEach(k => {\n\n            if (validQueryKeys.indexOf(k) > -1) {\n\n                const query = getQuery(k, params.getAll(k).join(','));\n\n                if (query.queryType === 'ordering') { docs = orderBy(query.fields, docs); }\n            }\n        });\n\n        ////////////////\n        // Distinct (4)\n        ////////////////\n\n        keys.forEach(k => {\n\n            if (validQueryKeys.indexOf(k) > -1) {\n\n                const query = getQuery(k, params.getAll(k).join(','));\n\n                if (query.queryType === 'distinct') { docs = distinct(query.fields, docs); }\n            }\n        });\n\n    }\n\n    return docs;\n}\n\nexport function filter(field: string, inputValue: string, docs: PwaDocument<any>[], lookup?: Lookup, isExclude = false): PwaDocument<any>[] {\n\n    // in lookup would same as eq with OR values\n    let f = (v: PwaDocument<any>) => inputValue.split(',').reduce((acc, cur) => acc || eq(v, field, cur), false);\n\n    if (lookup === 'gte') { f = v => inputValue.split(',').reduce((acc, cur) => acc || gte(v, field, cur), false); }\n\n    if (lookup === 'lte') { f = v => inputValue.split(',').reduce((acc, cur) => acc || lte(v, field, cur), false); }\n\n    if (lookup === 'gt') { f = v => inputValue.split(',').reduce((acc, cur) => acc || gt(v, field, cur), false); }\n\n    if (lookup === 'lt') { f = v => inputValue.split(',').reduce((acc, cur) => acc || lt(v, field, cur), false); }\n\n    if (lookup === 'range') { f = v => range(v, field, inputValue); }\n\n    if (lookup === 'startswith') { f = v => inputValue.split(',').reduce((acc, cur) => acc || startswith(v, field, cur), false); }\n\n    if (lookup === 'endswith') { f = v => inputValue.split(',').reduce((acc, cur) => acc || endswith(v, field, cur), false); }\n\n    if (lookup === 'iexact') { f = v => inputValue.split(',').reduce((acc, cur) => acc || iexact(v, field, cur), false); }\n\n    if (lookup === 'exact') { f = v => inputValue.split(',').reduce((acc, cur) => acc || exact(v, field, cur), false); }\n\n    if (lookup === 'icontains') { f = v => inputValue.split(',').reduce((acc, cur) => acc || icontains(v, field, cur), false); }\n\n    if (lookup === 'contains') { f = v => inputValue.split(',').reduce((acc, cur) => acc || contains(v, field, cur), false); }\n\n    if (lookup === 'isnull') { f = v => inputValue.split(',').reduce((acc, cur) => acc || isnull(v, field, cur), false); }\n\n    return docs.filter((v) => {\n\n        const o = f(v);\n\n        return isExclude ? !o : o;\n    });\n}\n\nexport function exclude(field: string, inputValue: string, docs: PwaDocument<any>[], lookup?: Lookup): PwaDocument<any>[] {\n\n    return filter(field, inputValue, docs, lookup, true);\n}\n\nexport function distinct(fields: string[], docs: PwaDocument<any>[]): PwaDocument<any>[] {\n\n    const uniques = new Set<FieldDataType>();\n\n    const distinctArray: PwaDocument<any>[] = [];\n\n    docs.forEach(v => {\n\n        const key = fields.reduce((acc, cur) => acc += `-${(v.data[cur] as FieldDataType)?.toString() || 'null'}`, '');\n\n        if (!uniques.has(key)) {\n\n            uniques.add(key);\n\n            distinctArray.push(v);\n        }\n    });\n\n    return distinctArray;\n}\n\nexport function orderBy(fields: string[], docs: PwaDocument<any>[]): PwaDocument<any>[] {\n\n    return docs.sort((a, b) => {\n\n        // tslint:disable-next-line: prefer-for-of\n        for (let i = 0; i < fields.length; i++) {\n\n            const order = fields[i].indexOf('-') === 0 ? 'desc' : 'asc';\n\n            const parseFieldName = order === 'desc' ? fields[i].split('-')[1] : fields[i];\n\n            if (!(parseFieldName in a?.data) || !(parseFieldName in b?.data)) { continue; }\n\n            let output = 0;\n\n            const isDate = parseDate(a.data[parseFieldName], b.data[parseFieldName]);\n\n            // tslint:disable-next-line: max-line-length\n            if (isDate && order === 'asc' && isDate.parsedFieldValue !== isDate.parsedInputValue) { \n\n                output = isDate.parsedFieldValue - isDate.parsedInputValue;\n\n                if (output > 0 || output < 0) { return output; }\n            }\n\n            // tslint:disable-next-line: max-line-length\n            if (isDate && order === 'desc' && isDate.parsedInputValue !== isDate.parsedFieldValue) { \n\n                output = isDate.parsedInputValue - isDate.parsedFieldValue;\n\n                if (output > 0 || output < 0) { return output; }\n            }\n\n            const isNumber = parseNumber(a.data[parseFieldName], b.data[parseFieldName]);\n\n            // tslint:disable-next-line: max-line-length\n            if (isNumber && order === 'asc' && isNumber.parsedFieldValue !== isNumber.parsedInputValue) {\n\n                output = isNumber.parsedFieldValue - isNumber.parsedInputValue;\n\n                if (output > 0 || output < 0) { return output; }\n            }\n\n            // tslint:disable-next-line: max-line-length\n            if (isNumber && order === 'desc' && isNumber.parsedInputValue !== isNumber.parsedFieldValue) {\n\n                output = isNumber.parsedInputValue - isNumber.parsedFieldValue;\n\n                if (output > 0 || output < 0) { return output; }\n            }\n\n            const valueA = (a.data[parseFieldName] as FieldDataType)?.toString() || '';\n\n            const valueB = (b.data[parseFieldName] as FieldDataType)?.toString() || '';\n\n            output = order === 'asc' ? valueA.localeCompare(valueB) : valueA.localeCompare(valueB) * -1;\n\n            if (output > 0 || output < 0) { return output; }\n\n        }\n\n        return 0;\n    });\n}\n","import { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n\nexport function enterZone<T>(zone: NgZone) {\n\n    return (source: Observable<T>) =>\n\n        new Observable<T>(observer =>\n\n            source.subscribe({\n                next: (x) => zone.run(() => observer.next(x)),\n                error: (err) => observer.error(err),\n                complete: () => observer.complete()\n            })\n        );\n}\n","import { Datatype, FileConfig, getSchema, pwaDocMethods, PwaDocType, PwaDocument } from '../definitions/document';\nimport { getCollectionCreator, PwaCollection, pwaCollectionMethods, ListResponse, PwaListResponse, CollectionListResponse } from '../definitions/collection';\nimport { switchMap, map, catchError, shareReplay, tap, finalize, startWith, take, auditTime, timeout } from 'rxjs/operators';\nimport { Observable, of, from, throwError, combineLatest } from 'rxjs';\nimport { HttpClient, HttpParams } from '@angular/common/http';\nimport { queryFilter } from './filters.resource';\nimport { RxCollectionCreator, RxDatabase } from 'rxdb';\nimport { NgZone } from '@angular/core';\nimport { enterZone } from './operators.resource';\nimport { ApiProgressService } from './apiProgress.resource';\nimport { SyncCollectionService } from './synchronise-collection.resource';\nimport { SynchroniseDocType } from '../definitions/synchronise-document';\nimport { CustomHttpParams } from './customParams.resource';\n\n\nexport interface RestAPICreator {\n    apiProgress?: ApiProgressService;\n    httpClient?: HttpClient;\n}\n\n\nexport interface CollectionAPICreator<Database> {\n    name?: string;\n    db$?: Observable<RxDatabase<Database>>;\n    collectionEvictTime$: Observable<number>;\n    collectionSkipDocuments$: Observable<number>;\n    synchroniseService?: SyncCollectionService;\n    attachments?: {};\n    options?: {};\n    migrationStrategies?: {};\n    autoMigrate?: boolean;\n    ngZone: NgZone;\n}\n\n\nexport interface PwaCollectionAPICreator<Database> {\n    collectionApiCreator: Partial<CollectionAPICreator<Database>>;\n    restApiCreator: Partial<RestAPICreator>;\n    cacheTimeInSeconds: number;\n}\n\n\nexport class RestAPI<T extends Datatype> {\n\n    private cache: Map<string, Observable<T> | Observable<ListResponse<T>>> = new Map();\n\n    constructor(private config: RestAPICreator) {}\n\n    ////////////////\n    // CRUD\n    ////////////////\n\n    get(url: string, params?: HttpParams): Observable<T> {\n\n        const paramsUrl = params?.keys().map(k => `${k}=${params.getAll(k).join(',')}`).join('&');\n\n        const cacheKey = `${url}${paramsUrl ? '?' + paramsUrl : ''}`;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.get(cacheKey)),\n\n            timeout(7500),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n\n            }),\n\n            shareReplay(1),\n\n        ) as Observable<T>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey) as Observable<T>;\n    }\n\n    post(url: string, data: Partial<T> | FormData): Observable<T> {\n\n        const cacheKey = url;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.post(url, data)),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n            }),\n\n            shareReplay(1),\n\n        )  as Observable<T>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey) as Observable<T>;\n    }\n\n    put(url: string, data: Partial<T> | FormData): Observable<T> {\n\n        const cacheKey = url;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.put(url, data)),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n            }),\n\n            shareReplay(1),\n\n        ) as Observable<T>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey) as Observable<T>;\n    }\n\n    list(url: string, params?: HttpParams): Observable<ListResponse<T>> {\n\n        const paramsUrl = params?.keys().map(k => `${k}=${params.getAll(k).join(',')}`).join('&');\n\n        const cacheKey = `${url}${paramsUrl ? '?' + paramsUrl : ''}`;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.get(cacheKey)),\n\n            timeout(7500),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n            }),\n\n            shareReplay(1),\n\n        ) as Observable<ListResponse<T>>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey) as Observable<ListResponse<T>>;\n    }\n\n    delete(url: string): Observable<any> {\n\n        const cacheKey = url;\n\n        const req = of(true).pipe(\n\n            tap(() => { if (!!this.config.apiProgress) { this.config.apiProgress.add(); } }),\n\n            switchMap(() => this.config.httpClient.delete(url)),\n\n            finalize(() => {\n\n                if (!!this.config.apiProgress) { this.config.apiProgress.remove(); }\n\n                if (this.cache.has(cacheKey)) { this.cache.delete(cacheKey); }\n            }),\n\n            shareReplay(1),\n\n        ) as Observable<any>;\n\n        if (!this.cache.has(cacheKey)) { this.cache.set(cacheKey, req); }\n\n        return this.cache.get(cacheKey);\n    }\n}\n\n\nexport class CollectionAPI<T extends Datatype, Database> {\n\n    private config: CollectionAPICreator<Database> = {\n        name: 'no_name_collection_api',\n        db$: of(),\n        collectionEvictTime$: of(86400),\n        collectionSkipDocuments$: of(500),\n        attachments: {},\n        options: {},\n        migrationStrategies: {},\n        autoMigrate: true,\n        ngZone: null\n    };\n\n    // tslint:disable-next-line: variable-name\n    private _collection$: Observable<PwaCollection<T>>;\n\n    private cache = new Map();\n\n    constructor(private _config: Partial<CollectionAPICreator<Database>>) {\n\n        this.config = {\n            ...this.config,\n            ...this._config\n        };\n    }\n\n    get collection$(): Observable<PwaCollection<T>> {\n\n        if (this._collection$) { return this._collection$; }\n\n        const collectionSchema = {};\n\n        collectionSchema[this.config.name] = getCollectionCreator(\n            this.config.name,\n            pwaCollectionMethods,\n            pwaDocMethods,\n            this.config.attachments,\n            this.config.options,\n            this.config.migrationStrategies,\n            this.config.autoMigrate\n        );\n\n        this._collection$ = this.config.db$.pipe(\n\n            switchMap(db => {\n\n                if (this.config.name in db) { return of(db[this.config.name]); }\n\n                return combineLatest([\n                    from(db.addCollections(collectionSchema as { [key: string]: RxCollectionCreator; })),\n                    this.config.collectionEvictTime$,\n                    this.config.collectionSkipDocuments$\n                ]).pipe(\n\n                    take(1),\n\n                    switchMap(([collections, collectionEvictTime, collectionSkipDocuments]) => {\n\n                        if (this.config.synchroniseService) {\n\n                            const data: SynchroniseDocType = {\n                                id: db.name + '-' + this.config.name,\n                                databaseOptions: JSON.stringify({\n                                    name: db.name,\n                                    eventReduce: db.eventReduce,\n                                    multiInstance: db.multiInstance,\n                                    options: db.options,\n                                    password: db.password,\n                                }),\n                                collectionEvictTime,\n                                collectionSkipDocuments,\n                                collectionName: this.config.name,\n                                collectionOptions: JSON.stringify({\n                                    name: this.config.name,\n                                    schema: getSchema(this.config.name),\n                                    attachments: collections[this.config.name].attachments,\n                                    autoMigrate: true,\n                                    cacheReplacementPolicy: collections[this.config.name].cacheReplacementPolicy,\n                                    methods: collections[this.config.name].methods,\n                                    migrationStrategies: collections[this.config.name].migrationStrategies,\n                                    options: collections[this.config.name].options,\n                                    statics: collections[this.config.name].statics,\n                                })\n                            };\n\n                            // add collection to synchronise collection service\n                            return this.config.synchroniseService.addSynchroniseDocument(data).pipe(\n\n                                map(() => collections[this.config.name] as PwaCollection<T>)\n                            );\n\n                        } else {\n\n                            return of(collections).pipe(\n\n                                map(() => collections[this.config.name] as PwaCollection<T>)\n                            );\n                        }\n\n                    })\n                );\n            }),\n\n            tap(col => col.preSave((plainData, rxDocument) => {\n\n                // modify anyField before saving\n                // add hook in synchronise-collection as well\n                plainData.createdAt = plainData.createdAt || new Date().getTime();\n                plainData.updatedAt = new Date().getTime();\n\n            }, false)),\n\n            shareReplay(1),\n\n            take(1),\n        );\n\n        return this._collection$;\n    }\n\n    makeTenantUrl(tenant: string, url: string): string {\n\n        return `${tenant}____${url}`;\n    }\n\n    filterDocs(\n        docs: Observable<PwaDocument<T>[]>,\n        url: string,\n        params?: HttpParams,\n        validQueryKeys = []\n    ): Observable<CollectionListResponse<T>> {\n\n        return docs.pipe(\n\n            // map(v => v.sort((a, b) => b.time - a.time)),\n\n            map(allDocs => queryFilter(validQueryKeys, params, allDocs)),\n\n            map(allDocs => {\n\n                // tslint:disable-next-line: radix\n                const start = parseInt(params?.get('offset') || '0');\n\n                // tslint:disable-next-line: radix\n                const end = start + parseInt(params?.get('limit') || '100');\n\n                const next = allDocs.length - end > 0 ? `${url}?${params.set('offset', end.toString()).toString()}` : null;\n\n                const previous = start > 0 ? `${url}?${params.set('offset', start.toString()).toString()}` : null;\n\n                return {next, previous, results: allDocs.slice(start, end), count: allDocs.length};\n            }),\n\n        );\n    }\n\n    ////////////////\n    // CRUD\n    ////////////////\n\n    getReactive(tenant: string, url: string): Observable<PwaDocument<T>> {\n\n        const cacheKey = tenant + url;\n\n        if (!this.cache.has(cacheKey)) {\n\n            const doc = this.collection$.pipe(\n\n                switchMap(col => col.findOne({selector: { tenantUrl: {$eq: this.makeTenantUrl(tenant, url)}}}).$),\n\n                shareReplay(1),\n\n                enterZone<PwaDocument<T>>(this.config.ngZone),\n            );\n\n            this.cache.set(cacheKey, doc);\n        }\n\n        return this.cache.get(cacheKey);\n\n    }\n\n    get(tenant: string, url: string): Observable<PwaDocument<T>> {\n\n        return this.getReactive(tenant, url).pipe(\n\n            take(1),\n        );\n    }\n\n    listReactive(tenant: string, url: string, params?: HttpParams, validQueryKeys = []): Observable<CollectionListResponse<T>> {\n\n        const cacheKey = tenant + url;\n\n        if (!this.cache.has(cacheKey)) {\n\n            const docs = this.collection$.pipe(\n\n                switchMap(col => col.find({ selector: {matchUrl: {$regex: new RegExp(`^${this.makeTenantUrl(tenant, url)}.*`)}} }).$),\n\n                shareReplay(1),\n            );\n\n            this.cache.set(cacheKey, docs);\n        }\n\n        return this.filterDocs(this.cache.get(cacheKey), url, params, validQueryKeys).pipe(\n\n            enterZone<CollectionListResponse<T>>(this.config.ngZone),\n        );\n    }\n\n    list(tenant: string, url: string, params?: HttpParams, validQueryKeys = []): Observable<CollectionListResponse<T>> {\n\n        return this.listReactive(tenant, url, params, validQueryKeys).pipe(\n\n            take(1)\n        );\n    }\n\n    /////////////\n    // Actions\n    /////////////\n\n    post(tenant: string, url: string, data: T, fileFields: FileConfig[] = []): Observable<PwaDocument<T>> {\n\n        return this.collection$.pipe(\n\n            switchMap(col => col.atomicUpsert({\n                tenantUrl: `${this.makeTenantUrl(tenant, url)}/${data.id}`,\n                matchUrl: `${this.makeTenantUrl(tenant, url)}/${data.id}`,\n                method: 'POST',\n                data,\n                error: null,\n                time: new Date().getTime(),\n                fileFields\n            })),\n        );\n    }\n\n    put(tenant: string, url: string, data: T, fileFields: FileConfig[] = []): Observable<PwaDocument<T>> {\n\n        return combineLatest([this.get(tenant, url), this.collection$]).pipe(\n\n            switchMap(([doc, col]) => {\n\n                if (doc) {\n\n                    return doc.atomicPatch({\n                        method: doc.method !== 'POST' ? 'PUT' : doc.method,\n                        data,\n                        error: null,\n                        time: doc.method === 'GET' ? new Date().getTime() : doc.time,\n                        fileFields\n                    });\n\n                } else {\n\n                    const docData: Partial<PwaDocType<T>> = {\n                        tenantUrl: this.makeTenantUrl(tenant, url),\n                        matchUrl: this.makeTenantUrl(tenant, url),\n                        data,\n                        method: 'PUT',\n                        error: null,\n                        time: new Date().getTime(),\n                        fileFields\n                    };\n\n                    return col.atomicUpsert(docData);\n                }\n\n            }),\n        );\n    }\n\n    delete(tenant: string, url: string, data?: T, fileFields: FileConfig[] = []): Observable<boolean | PwaDocument<T>> {\n\n        return this.get(tenant, url).pipe(\n\n            switchMap(doc => {\n\n                if (doc && doc.method === 'POST') {\n\n                    return from(doc.remove());\n\n                } else if (doc && (doc.method === 'PUT' || doc.method === 'DELETE')) {\n\n                    return from(doc.atomicPatch({method: 'DELETE', error: null}));\n\n                }  else if (doc) {\n\n                    return from(doc.atomicPatch({method: 'DELETE', error: null, time: new Date().getTime()}));\n\n                } else if (data) {\n\n                    const docData: Partial<PwaDocType<T>> = {\n                        tenantUrl: this.makeTenantUrl(tenant, url),\n                        matchUrl: this.makeTenantUrl(tenant, url),\n                        data,\n                        method: 'DELETE',\n                        error: null,\n                        time: new Date().getTime(),\n                        fileFields\n                    };\n\n                    return this.collection$.pipe(\n\n                        switchMap(col => col.atomicUpsert(docData))\n                    );\n\n                } else {\n\n                    return throwError('Document not found while deleting in database');\n                }\n\n            })\n        );\n    }\n\n    ///////////////////\n    // Conflict Actions\n    ///////////////////\n\n    createNew(tenant: string, url: string): Observable<PwaDocument<T>> {\n\n        return this.get(tenant, url).pipe(\n\n            switchMap(doc => {\n\n                if (!!doc && doc.method !== 'GET' && doc.method !== 'POST') {\n\n                    return from(doc.atomicPatch({method:'POST'}));\n                }\n\n                return throwError(`Cannot duplicate this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n            }),\n\n        );\n    }\n\n    deleteConflict(tenant: string, url: string): Observable<boolean> {\n\n        return this.get(tenant, url).pipe(\n\n            switchMap(doc => {\n\n                if (!!doc && doc.method !== 'GET') {\n\n                    return from(doc.remove());\n                }\n\n                return throwError(`Cannot delete this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n            }),\n        );\n    }\n}\n\n\nexport class PwaCollectionAPI<T extends Datatype, Database> {\n\n    private config: PwaCollectionAPICreator<Database> = {\n        restApiCreator: {},\n        collectionApiCreator: {\n            name: 'no_name_pwa_collection_api',\n            db$: of(),\n            collectionEvictTime$: of(86400),\n            collectionSkipDocuments$: of(500),\n            attachments: {},\n            options: {},\n            migrationStrategies: {},\n            autoMigrate: true,\n        },\n        cacheTimeInSeconds: 120\n    };\n\n    collectionAPI: CollectionAPI<T, Database>;\n    restAPI: RestAPI<T>;\n\n    constructor(private _config: Partial<PwaCollectionAPICreator<Database>>, ) {\n\n        this.config = {\n            ...this.config,\n            ...this._config,\n            restApiCreator: {\n                ...this.config.restApiCreator,\n                ...this._config.restApiCreator\n            },\n            collectionApiCreator: {\n                ...this.config.collectionApiCreator,\n                ...this._config.collectionApiCreator\n            }\n        };\n\n        this.restAPI        = new RestAPI(this.config.restApiCreator);\n        this.collectionAPI  = new CollectionAPI(this.config.collectionApiCreator);\n    }\n\n    //////////////\n    // Retrieve\n    //////////////\n\n    downloadRetrieve(doc: PwaDocument<T> | null, tenant: string, url: string, params?: HttpParams): Observable<PwaDocument<T> | null> {\n\n        if (!!doc && doc.method !== 'GET') { return of(doc); }\n\n        // check if document is within cacheTime\n        const currentTime = new Date().getTime();\n\n        if (!!doc && doc.time >= (currentTime - (this.config.cacheTimeInSeconds * 1000))) { return of(doc); }\n\n        return combineLatest([this.restAPI.get(url, params), this.collectionAPI.collection$]).pipe(\n\n            switchMap(([res, col]) => col.atomicUpsert({\n                tenantUrl: this.collectionAPI.makeTenantUrl(tenant, url),\n                matchUrl: this.collectionAPI.makeTenantUrl(tenant, url),\n                data: res,\n                method: 'GET',\n                error: null,\n                time: new Date().getTime(),\n            })),\n\n            catchError(() => of(doc)),\n        );\n    }\n\n    getReactive(tenant: string, url: string, params?: HttpParams, wait = false): Observable<PwaDocument<T>> {\n\n        return this.collectionAPI.get(tenant, url).pipe(\n\n            switchMap(doc => wait ?\n                this.downloadRetrieve(doc, tenant, url, params) :\n                this.downloadRetrieve(doc, tenant, url, params).pipe(startWith(null))\n            ),\n\n            switchMap(() => this.collectionAPI.getReactive(tenant, url)),\n\n            auditTime(1000 / 60),\n\n        );\n    }\n\n    get(tenant: string, url: string, params?: HttpParams): Observable<PwaDocument<T>> {\n\n        return this.getReactive(tenant, url, params, true).pipe(\n\n            take(1)\n        );\n    }\n\n    //////////////\n    // List\n    //////////////\n\n    // tslint:disable-next-line: max-line-length\n    downloadList(res: CollectionListResponse<T>, tenant: string, url: string, params?: HttpParams, indexedbUrl = (data: T, tenantUrl: string) => `${tenantUrl}/${data.id}`): Observable<ListResponse<T>> {\n\n        const currentTime = new Date().getTime();\n\n        // tslint:disable-next-line: radix\n        const limit = parseInt(params?.get('limit') || '100');\n\n        ////////////////////////////////////////////////////////////////\n        // Exclude recents or locally unsynced data in the api results\n        ////////////////////////////////////////////////////////////////\n\n        const ids = res.results\n            // tslint:disable-next-line: max-line-length\n            .filter(v => v.method === 'PUT' || v.method === 'DELETE' || (v.method === 'GET' && v.time >= (currentTime - (this.config.cacheTimeInSeconds * 1000))))\n            .map(v => v.data.id);\n\n        if (ids.length === limit) {\n\n            // pass if all results are excluded\n            return of({next: res.next, previous: res.previous, results: /*res.results.map(r => r.toJSON().data)*/ []});\n        }\n\n        params = params || new CustomHttpParams();\n\n        if (ids.length > 0) {\n\n            if (params.has('exclude:id.in')) {\n\n                params.delete('exclude:id.in');\n\n            }\n\n            params = params.append('exclude:id.in', ids.join(','));\n\n            params = params.set('limit', (limit - ids.length).toString());\n\n        }\n\n        return this.restAPI.list(url, params).pipe(\n\n            catchError(() => of({next: null, previous: null, results: []} as ListResponse<T>)),\n\n            switchMap(networkRes => this.collectionAPI.collection$.pipe(\n\n                switchMap(col => {\n\n                    // map network data to doctype\n                    const atomicWrites = networkRes.results\n                        .map(data => ({\n                            tenantUrl: indexedbUrl(data, this.collectionAPI.makeTenantUrl(tenant, url)),\n                            matchUrl: indexedbUrl(data, this.collectionAPI.makeTenantUrl(tenant, url)),\n                            data,\n                            method: 'GET',\n                            error: null,\n                            time: new Date().getTime(),\n                        })) as PwaDocType<T>[];\n\n                    if (atomicWrites.length > 0) {\n\n                        return from(col.bulkInsert(atomicWrites)).pipe(\n\n                            // tap(() => this.collectionAPI.triggerChange()),\n\n                            map(() => networkRes)\n                        );\n                    }\n\n                    return of(networkRes);\n                })\n            )),\n\n        );\n\n    }\n\n    listReactive(\n        tenant: string,\n        url: string,\n        params?: HttpParams,\n        validQueryKeys = [],\n        indexedbUrl = (data: T, tenantUrl: string) => `${tenantUrl}/${data.id}`,\n        wait = false\n    ): Observable<PwaListResponse<T>> {\n\n        return this.collectionAPI.list(tenant, url, params, validQueryKeys).pipe(\n\n            switchMap(idbRes => wait ?\n                this.downloadList(idbRes, tenant, url, params, indexedbUrl) :\n                this.downloadList(idbRes, tenant, url, params, indexedbUrl).pipe(startWith({next: null, previous: null, results: []}))),\n\n            switchMap((networkRes) => this.collectionAPI.listReactive(tenant, url, params, validQueryKeys).pipe(\n\n                map(res => ({\n                    next: networkRes?.next || res.next,\n                    previous: networkRes?.previous || res.previous,\n                    results: res.results\n                })),\n\n            )),\n\n        ) as Observable<PwaListResponse<T>>;\n\n    }\n\n    list(tenant: string, url: string, params?: HttpParams, validQueryKeys = [], indexedbUrl = (data: T, tenantUrl: string) => `${tenantUrl}/${data.id}`): Observable<PwaListResponse<T>> {\n\n        return this.listReactive(tenant, url, params, validQueryKeys, indexedbUrl, true).pipe(\n\n            take(1)\n        );\n\n    }\n}\n","import { createRxDatabase, addRxPlugin, RxDatabase, RxDatabaseCreator, addPouchPlugin, getRxStoragePouch } from 'rxdb';\nimport { from, Observable } from 'rxjs';\nimport { map, switchMap, startWith, shareReplay, first } from 'rxjs/operators';\nimport { RxDBEncryptionPlugin } from 'rxdb/plugins/encryption';\nimport { RxDBLeaderElectionPlugin } from 'rxdb/plugins/leader-election';\nimport { RxDBValidatePlugin } from 'rxdb/plugins/validate';\nimport { RxDBMigrationPlugin } from 'rxdb/plugins/migration';\n\naddPouchPlugin(require('pouchdb-adapter-idb'));\n\n\nexport interface PwaDatabaseCreator {\n    dbCreator: Partial<RxDatabaseCreator>;\n}\n\n\nexport class PwaDatabaseService<T> {\n\n    // tslint:disable-next-line: variable-name\n    private _db$: Observable<RxDatabase<T>>;\n\n    constructor(private _config: PwaDatabaseCreator) {}\n\n    get db$(): Observable<RxDatabase<T>> {\n\n        if (this._db$) { return this._db$; }\n\n        // add encryption plugin\n        addRxPlugin(RxDBEncryptionPlugin);\n\n        // add leader election plugin\n        addRxPlugin(RxDBLeaderElectionPlugin);\n\n        // add schema validate plugin\n        addRxPlugin(RxDBValidatePlugin);\n\n        // add migration plugin\n        addRxPlugin(RxDBMigrationPlugin);\n\n        const pouchAdapter = getRxStoragePouch('idb');\n\n        pouchAdapter.pouchSettings.revs_limit       = 0,\n        pouchAdapter.pouchSettings.auto_compaction  = true;\n\n        this._db$ = from(createRxDatabase({\n            name: 'pwadb',\n            storage: pouchAdapter,\n            password: 'ubT6LIL7ne2bdpze0V1DaeOGKKqYMWVF',\n            multiInstance: true,\n            eventReduce: true,\n            ...this._config.dbCreator\n        })).pipe(\n\n            switchMap((db: any) => from(db.waitForLeadership()).pipe(\n\n                startWith(null),\n\n                map(() => db),\n            )),\n\n            shareReplay(1),\n\n            first(),\n\n        );\n\n        return this._db$;\n\n    }\n\n}\n","import { Injectable, NgZone } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { auditTime, distinctUntilChanged, map } from 'rxjs/operators';\nimport { enterZone } from './operators.resource';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class ApiProgressService {\n\n    isProgressing$: Observable<boolean>;\n    private progress: BehaviorSubject<boolean[]>;\n\n    constructor(private zone: NgZone) {\n\n        this.progress = new BehaviorSubject([]);\n\n        this.isProgressing$ = this.progress.asObservable().pipe(\n\n            map(v => !!v.length),\n\n            distinctUntilChanged(),\n\n            auditTime(1000 / 60),\n\n            enterZone(zone)\n        );\n    }\n\n    add(): void {\n\n        const newProgress: boolean[] =  this.progress.value;\n\n        newProgress.push(true);\n\n        this.progress.next(newProgress);\n    }\n\n    remove(): void {\n\n        if (this.isProgressing()) {\n\n            const newProgress: boolean[] =  this.progress.value;\n\n            newProgress.pop();\n\n            this.progress.next(newProgress);\n        }\n    }\n\n    isProgressing(): boolean {\n\n        return !!this.progress.value.length;\n    }\n}\n","\nexport function flatten<T>(arr: T[], result = []): any[] {\n\n    for (let i = 0, length = arr.length; i < length; i++) {\n\n        const value = arr[i];\n\n        if (Array.isArray(value)) {\n\n            flatten(value, result);\n\n        } else {\n\n            result.push(value);\n        }\n    }\n\n    return result;\n}\n","import { BehaviorSubject, Observable, combineLatest } from 'rxjs';\nimport { Datatype, PwaDocument } from '../definitions/document';\nimport { HttpParams } from '@angular/common/http';\nimport { PwaListResponse } from '../definitions/collection';\nimport { switchMap, tap, shareReplay, map, filter, auditTime, distinctUntilChanged } from 'rxjs/operators';\nimport { NgZone } from '@angular/core';\nimport { enterZone } from './operators.resource';\nimport { CustomHttpParams } from './customParams.resource';\nimport { flatten } from './misc.resource';\n\n/////////////////////\n// Interfaces\n/////////////////////\n\nexport interface TableDatabase<T extends TableDataType> {\n\n    fetch: (params?: HttpParams) => Observable<PwaListResponse<T>>;\n\n    fetchReactive: (params?: HttpParams) => Observable<PwaListResponse<T>>;\n\n    getDatabase?: (limit?: number) => Database<T>;\n\n    getReactiveDatabase?: (limit?: number) => ReactiveDatabase<T>;\n}\n\nexport interface IBaseDatabase {\n    reset: () => void;\n    loadMore: () => void;\n}\n\nexport interface TableDataType extends Datatype {\n    created_at?: string;\n}\n\n///////////////////\n// Tables\n///////////////////\n\nexport class BaseDatabase<T extends TableDataType> implements IBaseDatabase {\n\n    queueChange: BehaviorSubject<Observable<PwaListResponse<T>>[]>;\n    data: PwaDocument<T>[];\n\n    _isLoadingChange: BehaviorSubject<boolean>;\n    isLoadingChange: Observable<boolean>;\n    lastRes: PwaListResponse<T>;\n\n    // tslint:disable-next-line: variable-name\n    private _httpParams: HttpParams;\n\n    get httpParams() { return this._httpParams; }\n    set httpParams(v: HttpParams) {\n\n        this._httpParams = v;\n\n        this.reset();\n    }\n\n    get isLoading() { return this._isLoadingChange.value; }\n    get offset() { return this.data.length; }\n    get isLoadable(): boolean { return !!this.lastRes?.next; }\n    get limit() { return this.__limit; }\n\n    constructor(private __limit: number, private __zone: NgZone) {\n\n        this.data               = [];\n        this.queueChange        = new BehaviorSubject([]);\n        this._isLoadingChange \t= new BehaviorSubject(false);\n\n        this._httpParams        = new CustomHttpParams();\n\n        this.isLoadingChange    = this._isLoadingChange.asObservable().pipe(\n\n            distinctUntilChanged(),\n\n            enterZone(this.__zone)\n        );\n    }\n\n    reset() {\n\n        this._httpParams = this.httpParams.delete('cursor');\n        this._httpParams = this.httpParams.set('offset', '0');\n        this._httpParams = this.httpParams.set('limit', this.limit.toString());\n\n        if (!this.httpParams.has('ordering')) { this._httpParams = this.httpParams.set('ordering', '-created_at'); }\n    }\n\n    loadMore() {\n\n        // set queryparams from next url\n        if (this.lastRes?.next) {\n\n            const split = this.lastRes.next.split('?');\n\n            if (split.length > 1) {\n\n                split[1].split('&').forEach(q => {\n\n                    const queryParam = q.split('=');\n\n                    this._httpParams = this.httpParams.set(decodeURIComponent(queryParam[0]), decodeURIComponent(queryParam[1]));\n                });\n            }\n        }\n\n        this._httpParams = this.httpParams.set('offset', this.offset.toString());\n        this._httpParams = this.httpParams.set('limit', this.limit.toString());\n    }\n\n}\n\nexport class Database<T extends TableDataType> extends BaseDatabase<T> {\n\n    dataChange: Observable<PwaDocument<T>[]>;\n\n    constructor(private apiService: TableDatabase<T>, private zone: NgZone, private _limit = 20) {\n\n        super(_limit, zone);\n\n        this.dataChange = this.queueChange.asObservable().pipe(\n\n            tap(v => { if (!v.length) { this.reset(); } }),\n\n            filter(v => !!v.length),\n\n            tap(() => this._isLoadingChange.next(true)),\n\n            switchMap(v => combineLatest(v)),\n\n            auditTime(1000 / 60),\n\n            tap(res => this.lastRes = res.length > 0 ? res[res.length - 1] : null),\n\n            map(res => flatten(res.map(v => v.results)) as PwaDocument<T>[]),\n\n            tap(v => this.data = v),\n\n            tap(() => this._isLoadingChange.next(false)),\n\n            shareReplay(1),\n\n        ) as Observable<PwaDocument<T>[]>;\n    }\n\n    getView(httpParams: HttpParams): Observable<PwaListResponse<T>> {\n\n        return this.apiService.fetch(httpParams).pipe(\n\n            shareReplay(1)\n        );\n    }\n\n    reset() {\n\n        super.reset();\n\n        // make view\n        const view = this.getView(this.httpParams);\n\n        // push to queue\n        this.queueChange.next([view]);\n    }\n\n    loadMore() {\n\n        if (this.isLoading) { return; }\n\n        super.loadMore();\n\n        // make view\n        const view = this.getView(this.httpParams);\n\n        // push to queue\n        this.queueChange.next(flatten([this.queueChange.value, view]));\n    }\n\n}\n\n\nexport class ReactiveDatabase<T extends TableDataType> extends BaseDatabase<T> {\n\n    dataChange: Observable<PwaDocument<T>[]>;\n\n    constructor(private apiService: TableDatabase<T>, private zone: NgZone, private _limit = 20) {\n\n        super(_limit, zone);\n\n        this.dataChange = this.queueChange.asObservable().pipe(\n\n            tap(v => { if (!v.length) { this.reset(); } }),\n\n            filter(v => !!v.length),\n\n            tap(() => this._isLoadingChange.next(true)),\n\n            switchMap(v => combineLatest(v)),\n\n            auditTime(1000 / 60),\n\n            tap(res => this.lastRes = res.length > 0 ? res[res.length - 1] : null),\n\n            map(res => flatten(res.map(v => v.results)) as PwaDocument<T>[]),\n\n            tap(v => this.data = v),\n\n            tap(() => this._isLoadingChange.next(false)),\n\n            shareReplay(1),\n\n        ) as Observable<PwaDocument<T>[]>;\n    }\n\n    getView(httpParams: HttpParams): Observable<PwaListResponse<T>> {\n\n        return this.apiService.fetchReactive(httpParams).pipe(\n\n            shareReplay(1)\n        );\n    }\n\n    reset() {\n\n        super.reset();\n\n        // make view\n        const view = this.getView(this.httpParams);\n\n        // push to queue\n        this.queueChange.next([view]);\n    }\n\n    loadMore() {\n\n        if (this.isLoading) { return; }\n\n        super.loadMore();\n\n        // make view\n        const view = this.getView(this.httpParams);\n\n        // push to queue\n        this.queueChange.next(flatten([this.queueChange.value, view]));\n    }\n}\n","import { HttpParams } from '@angular/common/http';\nimport { BehaviorSubject, combineLatest, merge, Observable, of, Subscription } from 'rxjs';\nimport { auditTime, filter, map, mergeMap, shareReplay, switchMap } from 'rxjs/operators';\nimport { Datatype, PwaDocument } from '../definitions/document';\nimport { Database, ReactiveDatabase, TableDataType } from './table.resource';\nimport {CollectionViewer, SelectionChange, DataSource} from '@angular/cdk/collections';\nimport {FlatTreeControl} from '@angular/cdk/tree';\nimport { CustomHttpParams } from './customParams.resource';\nimport { flatten } from './misc.resource';\n\n///////////////////\n// Interfaces\n///////////////////\n\nexport type TreeNode<T extends TableDataType> = {item: PwaDocument<T>, children: Observable<TreeNode<any>[]>};\n\nexport interface DatabaseInformation<T extends TableDataType> {\n    getDatabase: (limit?: number) => Database<T> | ReactiveDatabase<T>;\n    onCreationSetup?: (parentDoc: PwaDocument<T> | null, db: Database<T> | ReactiveDatabase<T>, params: HttpParams) => void;\n    isRecursive: boolean;\n    children: TreeInformation<T>;\n}\n\nexport interface TreeInformation<T extends TableDataType> {\n    [key: string]: DatabaseInformation<T>;\n}\n\n\n///////////////////\n// Trees\n///////////////////\n\n\nexport class TreeDatabase<T extends TableDataType> {\n\n    childTreeMap: Map<PwaDocument<any>, TreeNode<any>>;\n    databaseMap: Map<PwaDocument<any>, Database<any> | ReactiveDatabase<any>>;\n\n    databaseKeyMap: Map<string, Database<any> | ReactiveDatabase<any>>;\n\n    dataChange: Observable<TreeNode<T>[]>;\n\n    private queueChange: BehaviorSubject<any>;\n    // tslint:disable-next-line: variable-name\n    private _httpParams: HttpParams;\n\n    get httpParams() { return this._httpParams; }\n    set httpParams(v: HttpParams) {\n\n        this._httpParams = v;\n\n        this.reset();\n    }\n\n    constructor(private treeInfo: TreeInformation<T>) {\n\n        this.databaseMap    = new Map();\n        this.databaseKeyMap = new Map();\n        this.childTreeMap   = new Map();\n\n        this._httpParams  = new CustomHttpParams();\n        this.queueChange  = new BehaviorSubject(true);\n\n        this.dataChange = this.queueChange.asObservable().pipe(\n\n            switchMap(() => this.buildTree(this.treeInfo, null, this.httpParams)),\n\n            shareReplay(1),\n\n        );\n    }\n\n    buildTree(treeInfo: TreeInformation<T>, parentDoc: PwaDocument<T> = null, parentParams = new CustomHttpParams(), parentKey = null): Observable<TreeNode<T>[]> {\n\n        const treeNodes = Object.keys(treeInfo).map(key => {\n\n            const db = treeInfo[key].getDatabase();\n\n            const currentDatabaseMapKey = parentKey && parentDoc ? `${parentKey}~${parentDoc.tenantUrl}--${key}` : key;\n\n            this.databaseKeyMap.set(currentDatabaseMapKey, db);\n\n            // check current httpParams\n            const possibleParamKeys = parentParams.keys().filter(pk => pk && pk.includes(`${key}--`));\n\n            // create new params associated to this database\n            let currentParams = new CustomHttpParams();\n\n            // extract childParams\n            possibleParamKeys.forEach(pk => {\n\n                const paramName = pk.split(`${key}--`)[1];\n\n                // only set param associated to this database\n                // extra '--' would mean params to nested database\n                if (!paramName.includes('--')) {\n\n                    currentParams = currentParams.set(paramName, parentParams.get(pk));\n                }\n\n            });\n\n            // run callback\n            treeInfo[key].onCreationSetup ? treeInfo[key].onCreationSetup(parentDoc, db, currentParams) : db.httpParams = currentParams;\n\n            return db.dataChange.pipe(\n\n                map(docs => {\n\n                    const obsArr = docs.map(doc => {\n\n                        ///////////////////\n                        // Database Map\n                        ///////////////////\n                        if (!this.databaseMap.has(doc)) { this.databaseMap.set(doc, db); }\n\n                        ///////////////////\n                        // Child Tree\n                        ///////////////////\n\n                        if (!this.childTreeMap.has(doc)) {\n\n                            // add the current treeInfo in children\n                            // if isRecursive == true\n                            if (treeInfo[key].isRecursive) {\n\n                                treeInfo[key].children[key] = treeInfo[key];\n\n                            }\n\n                            const childTree = this.buildTree(treeInfo[key].children, doc, parentParams, currentDatabaseMapKey).pipe(\n\n                                shareReplay(1),\n\n                            ) as Observable<TreeNode<any>[]>;\n\n                            this.childTreeMap.set(doc, {item: doc, children: childTree});\n                        }\n\n                        return this.childTreeMap.get(doc);\n\n                    });\n\n                    return obsArr;\n                }),\n\n            );\n        });\n\n        return combineLatest(treeNodes).pipe(\n\n            map(nodes => flatten(nodes)),\n\n        );\n    }\n\n    reset() {\n\n        this.databaseMap.clear();\n        this.databaseKeyMap.clear();\n        this.childTreeMap.clear();\n\n        this.queueChange.next(true);\n    }\n\n}\n\n/////////////////////\n// DataSource\n/////////////////////\n\n/** Flat node with expandable and level information */\nexport class DynamicFlatNode<T extends TableDataType> {\n    constructor(\n        public item: PwaDocument<T> | string,\n        public level = 1,\n        public expandable = false,\n    ) {}\n}\n\nexport class DynamicTreeFlattener<T, F> {\n\n    flatNodeMap = new Map<T, F>();\n    structuredNodeMap = new Map<F, T>();\n    parentNodeMap = new Map<F, F>();\n\n    constructor(public transformFunction: (node: T, level: number) => F,\n                public getLevel: (node: F) => number,\n                public isExpandable: (node: F) => boolean,\n                public getChildren: (node: T) =>\n                    Observable<T[]> | T[] | undefined | null) {}\n\n    _flattenNode(node: T, level: number): F {\n\n        if (!this.flatNodeMap.has(node)) {\n\n            const flatNode = this.transformFunction(node, level);\n\n            this.flatNodeMap.set(node, flatNode);\n            this.structuredNodeMap.set(flatNode, node);\n        }\n\n        return this.flatNodeMap.get(node);\n    }\n\n    insertChildrenFlatNodes(parentNode: F, children: F[], resultNodes: F[]): F[] {\n\n        const index = resultNodes.indexOf(parentNode);\n\n        resultNodes.splice(index + 1, 0, ...children);\n\n        children.filter(c => !this.parentNodeMap.has(c)).forEach(c => this.parentNodeMap.set(c, parentNode));\n\n        return resultNodes;\n    }\n\n    removeChildrenFlatNodes(parentNode: F, resultNodes: F[]): F[] {\n\n        const index = resultNodes.indexOf(parentNode);\n\n        let count = 0;\n\n        for (let i = index + 1; i < resultNodes.length && this.getLevel(resultNodes[i]) > this.getLevel(parentNode); i++, count++) {}\n\n        const children = resultNodes.splice(index + 1, count);\n\n        children.filter(c => this.parentNodeMap.has(c)).forEach(c => this.parentNodeMap.delete(c));\n\n        return resultNodes;\n    }\n\n    addChildrenFlatNode(parentFlatNode: F, resultNodes: F[]): Observable<F[]> {\n\n        // fetch structuredNode corresponding to this parentFlatNode\n        const structuredNode = this.structuredNodeMap.get(parentFlatNode);\n\n        // fetch structuredChildrenNode corresponding to this structuredNode\n        const structuredChildrenNodes = this.getChildren(structuredNode);\n\n        if (structuredChildrenNodes) {\n\n            if (Array.isArray(structuredChildrenNodes)) {\n\n                const flatChildren = structuredChildrenNodes.map(s => this._flattenNode(s, this.getLevel(parentFlatNode) + 1));\n\n                return of(this.insertChildrenFlatNodes(parentFlatNode, flatChildren, resultNodes));\n\n            } else {\n\n                return structuredChildrenNodes.pipe(\n\n                    map(children => children.map(s => this._flattenNode(s, this.getLevel(parentFlatNode) + 1))),\n\n                    map(flatChildren => {\n\n                        resultNodes = this.removeChildrenFlatNodes(parentFlatNode, resultNodes);\n\n                        return this.insertChildrenFlatNodes(parentFlatNode, flatChildren, resultNodes);\n                    }),\n                );\n\n            }\n        }\n\n        return of(resultNodes);\n    }\n\n    /**\n     * Flatten a list of node type T to flattened version of node F.\n     * Please note that type T may be nested, and the length of `structuredData` may be different\n     * from that of returned list `F[]`.\n     */\n    flattenNodes(structuredData: T[]): F[] {\n\n        return structuredData.map(node => this._flattenNode(node, 0));\n    }\n\n}\n\nexport class DynamicFlatTreeDataSource<T, F extends Datatype> implements DataSource<F> {\n\n    readonly _flattenedData = new BehaviorSubject<F[]>([]);\n    private readonly _data = new BehaviorSubject<T[]>([]);\n\n    subs = new Subscription();\n\n    get data() { return this._data.value; }\n\n    set data(value: T[]) {\n\n        this._data.next(value);\n\n        const flattenedData = this._treeFlattener.flattenNodes(this.data);\n\n        this._treeControl.expansionModel.clear();\n\n        this._treeControl.dataNodes = flattenedData;\n\n        this.flattenedData = flattenedData;\n    }\n\n    mergeData(value: T[]) {\n\n        this._data.next(value);\n\n        const flattenedData = this._treeFlattener.flattenNodes(this.data);\n\n        const mergeObj: {[key: string]: F} = {};\n\n        this.flattenedData.concat(flattenedData).forEach(f => mergeObj[f.id] = f);\n\n        const mergedFlattenedData = Object.values(mergeObj);\n\n        this._treeControl.dataNodes = mergedFlattenedData;\n\n        this.flattenedData = mergedFlattenedData;\n    }\n\n    get flattenedData(): F[] { return this._flattenedData.value; }\n    set flattenedData(v: F[]) { this._flattenedData.next(v); }\n\n    constructor(public _treeControl: FlatTreeControl<F>, public _treeFlattener: DynamicTreeFlattener<T, F>, initialData?: T[]) {\n\n        if (initialData) {\n            // Assign the data through the constructor to ensure that all of the logic is executed.\n            this.data = initialData;\n        }\n    }\n\n    /**\n     * Toggle the node, remove from display list\n     */\n    toggleNode(flatNode: F, expand: boolean): Observable<F[]> {\n\n        if (expand) {\n\n            if (this._treeFlattener.isExpandable(flatNode)) {\n\n                return this._treeFlattener.addChildrenFlatNode(flatNode, this.flattenedData);\n            }\n\n            return this._flattenedData.asObservable();\n\n        } else {\n\n            return of(this._treeFlattener.removeChildrenFlatNodes(flatNode, this.flattenedData));\n        }\n    }\n\n    /** Handle expand/collapse behaviors */\n    handleTreeControl(change: SelectionChange<F>): Observable<F[]> {\n\n        if (change.added) {\n\n            const obsArray = change.added.map(node => this.toggleNode(node, true));\n\n            return combineLatest(obsArray).pipe(\n\n                map((o) => o.length > 0 ? o[obsArray.length - 1] : [])\n            );\n        }\n\n        if (change.removed) {\n\n            const obsArray = change.removed.slice().reverse().map(node => this.toggleNode(node, false));\n\n            return combineLatest(obsArray).pipe(\n\n                map((o) => o.length > 0 ? o[obsArray.length - 1] : [])\n\n            );\n        }\n\n    }\n\n    connect(collectionViewer: CollectionViewer): Observable<F[]> {\n\n        const changeObs = this._treeControl.expansionModel.changed.pipe(\n\n            filter(change => !!(change as SelectionChange<F>).added?.length || !!(change as SelectionChange<F>).removed?.length),\n\n            mergeMap(change => this.handleTreeControl(change as SelectionChange<F>)),\n\n            auditTime(1000 / 60)\n        );\n\n        const subs = changeObs.subscribe((v) => {\n\n            this._treeControl.dataNodes = v;\n\n            this.flattenedData = v;\n        });\n\n        this.subs.add(subs);\n\n        return merge(collectionViewer.viewChange, this._flattenedData.asObservable()).pipe(map(() => this.flattenedData));\n    }\n\n    disconnect(collectionViewer: CollectionViewer): void {\n\n        this.subs.unsubscribe();\n    }\n}\n","import { HttpClient } from '@angular/common/http';\nimport { NgZone } from '@angular/core';\nimport { RxCollectionCreator, RxDatabase } from 'rxdb';\nimport { BehaviorSubject, combineLatest, from, Observable, of, throwError } from 'rxjs';\nimport { auditTime, catchError, concatMap, filter, finalize, first, map, shareReplay, switchMap, tap } from 'rxjs/operators';\nimport { getCollectionCreator, PwaCollection, pwaCollectionMethods } from '../definitions/collection';\nimport { pwaDocMethods, PwaDocument } from '../definitions/document';\nimport { getSynchroniseCollectionCreator, SynchroniseCollection, synchroniseCollectionMethods } from '../definitions/synchronise-collection';\nimport { synchroniseDocMethods, SynchroniseDocType, SynchroniseDocument } from '../definitions/synchronise-document';\nimport { enterZone } from './operators.resource';\nimport { PwaDatabaseService } from './database.resource';\nimport { flatten } from './misc.resource';\n\ninterface Extras {\n    collection: PwaCollection<any>;\n}\n\ntype SynchroniseDocTypeExtras = SynchroniseDocType & Extras;\n\n\nexport interface SyncCollectionServiceCreator {\n    name: string;\n    db$: Observable<RxDatabase<any>>;\n    attachments?: {};\n    options?: {};\n    migrationStrategies?: {};\n    autoMigrate?: boolean;\n    ngZone: NgZone;\n    httpClient: HttpClient;\n}\n\n\nexport class SyncCollectionService {\n\n    // tslint:disable-next-line: variable-name\n    private _collection$: Observable<SynchroniseCollection>;\n\n    private retryChange: BehaviorSubject<boolean>;\n\n    private config: SyncCollectionServiceCreator = {\n        name: 'no_name_sync_collection',\n        db$: of(),\n        attachments: {},\n        options: {},\n        migrationStrategies: {},\n        autoMigrate: true,\n        ngZone: null,\n        httpClient: null,\n    };\n\n    storedCollections: Observable<SynchroniseDocTypeExtras[]>;\n\n    constructor(private _config: Partial<SyncCollectionServiceCreator>) {\n\n        this.config = {\n            ...this.config,\n            ...this._config\n        };\n\n        this.retryChange = new BehaviorSubject(true);\n\n        this.storedCollections = this.collection$.pipe(\n\n            switchMap(col => col.find().$),\n\n            map(docs => docs.map(d => d.toJSON())),\n\n            map(docTypes => {\n\n                // reduce collections to database wise\n                const databasesSchema: {[key: string]: SynchroniseDocType[]} = {};\n\n                docTypes.forEach(d => {\n\n                    const key = d.databaseOptions;\n\n                    key in databasesSchema ? databasesSchema[key].push(d) : databasesSchema[key] = [d];\n                });\n\n                // map RxDatabase and collectionNames\n\n                const databasesMap: {database: Observable<RxDatabase>, collectionInfo: SynchroniseDocType[]}[] = [];\n\n                Object.keys(databasesSchema).forEach(schema => {\n\n                    const pwaDatabaseService = new PwaDatabaseService<any>({dbCreator: {...JSON.parse(schema), ignoreDuplicate: true}});\n\n                    databasesMap.push({database: pwaDatabaseService.db$, collectionInfo: databasesSchema[schema]});\n                });\n\n                return databasesMap;\n            }),\n\n            switchMap(databasesMap => combineLatest(databasesMap.map(m => {\n\n                return m.database.pipe(\n\n                    switchMap(db => {\n\n                        const collectionInfoKeyValue: {[key: string]: SynchroniseDocType} = m.collectionInfo.reduce(\n                            (cur: SynchroniseDocType, acc: {}) => {\n\n                                acc[cur.collectionName] = cur;\n\n                                return acc;\n\n                            }, {});\n\n                        const collections = {};\n\n                        m.collectionInfo.forEach(i => {\n\n                            const collectionOptions = JSON.parse(i.collectionOptions) as RxCollectionCreator;\n\n                            collections[i.collectionName] = getCollectionCreator(\n                                i.collectionName,\n                                pwaCollectionMethods,\n                                pwaDocMethods,\n                                collectionOptions.attachments,\n                                collectionOptions.options,\n                                collectionOptions.migrationStrategies,\n                                collectionOptions.autoMigrate\n                            );\n                        });\n\n                        return from(db.addCollections(collections)).pipe(\n\n                            map(v => Object.keys(v).map(k => ({\n                                collection: v[k] as PwaCollection<any>,\n                                ...collectionInfoKeyValue[k],\n                            })))\n                        );\n                    })\n                );\n\n            }))),\n\n            map(v => flatten(v)),\n\n            tap((v: SynchroniseDocTypeExtras[]) =>  {\n\n                v.forEach(docType => {\n\n                    docType.collection.preSave((plainData, rxDocument) => {\n\n                        // modify anyField before saving\n                        plainData.createdAt = plainData.createdAt || new Date().getTime();\n                        plainData.updatedAt = new Date().getTime();\n\n                    }, false);\n\n                });\n            }),\n\n            shareReplay(1),\n        );\n    }\n\n    get collection$(): Observable<SynchroniseCollection> {\n\n        if (this._collection$) { return this._collection$; }\n\n        const collectionSchema = {};\n\n        collectionSchema[this.config.name] = getSynchroniseCollectionCreator(\n            this.config.name,\n            synchroniseCollectionMethods,\n            synchroniseDocMethods,\n            this.config.attachments,\n            this.config.options,\n            this.config.migrationStrategies,\n            this.config.autoMigrate\n        );\n\n        this._collection$ = this.config.db$.pipe(\n\n            // tslint:disable-next-line: max-line-length\n            switchMap(db => from(db.addCollections(collectionSchema))),\n\n            map(collections => collections[this.config.name]),\n\n            shareReplay(1),\n\n            first()\n        );\n\n        return this._collection$;\n    }\n\n\n    addSynchroniseDocument(data: SynchroniseDocType): Observable<SynchroniseDocument> {\n\n        return this.collection$.pipe(\n\n            switchMap(col => col.atomicUpsert(data))\n        );\n    }\n\n    /////////////////////////////\n    // Synchronisation Management\n    //////////////////////////////\n\n    startSync() {\n\n        this.retryChange.next(true);\n    }\n\n    stopSync() {\n\n        this.retryChange.next(false);\n    }\n\n    unsynchronised(tenant: string, order: 'desc' | 'asc' = 'asc'): Observable<PwaDocument<any>[]> {\n\n        return this.storedCollections.pipe(\n\n            switchMap((collectionsInfo) => {\n\n                const query = {\n                    selector: {\n                        matchUrl: {$regex: new RegExp(`^${tenant}.*`)},\n                        method: {$ne: 'GET'}\n                    }\n                };\n\n                const sortedDocs$ = collectionsInfo.map(k => {\n\n                    return from(k.collection.find(query).$.pipe(\n\n                        auditTime(1000 / 60)\n                    ));\n                });\n\n                return combineLatest(sortedDocs$);\n\n            }),\n\n            map(sortedDocs => flatten(sortedDocs)),\n\n            // tslint:disable-next-line: max-line-length\n            map((sortedDocs: PwaDocument<any>[]) => sortedDocs.sort((a, b) => order === 'asc' ? a.time - b.time : b.time - a.time)),\n\n            enterZone<PwaDocument<any>[]>(this.config.ngZone),\n        );\n    }\n\n    synchronise(tenant: string): Observable<PwaDocument<any> | boolean> {\n\n        const pop: Observable<PwaDocument<any>> = this.unsynchronised(tenant, 'asc').pipe(\n\n            filter(sortedDocs => sortedDocs.length > 0),\n\n            map(sortedDocs => sortedDocs[0]),\n\n        );\n\n        const hit = pop.pipe(\n\n            concatMap(doc => {\n\n                if (doc.method === 'POST') {\n\n                    const url = doc.tenantUrl.split('____')[1].split('/');\n\n                    url.splice(url.length - 1, 1);\n\n                    let formData: FormData | {};\n\n                    if (doc.fileFields.length) {\n\n                        //////////////////\n                        // Multipart/form\n                        //////////////////\n\n                        formData = createFormData(doc.toJSON().data) as FormData;\n\n                        doc.fileFields.forEach(k => {\n\n                            (formData as FormData).delete(k.fileField);\n\n                            (formData as FormData).delete(k.fileNameField);\n\n                            (formData as FormData).delete(k.fileType);\n\n                            if (k.fileKeyField && k.fileField && k.fileType) (formData as FormData).append(k.fileKeyField, new File([new Uint8Array(JSON.parse(doc.data[k.fileField])).buffer], k.fileNameField || 'Unknown', {type: k.fileType}));\n                        });\n\n                    } else {\n\n                        ////////////////////\n                        // Application/json\n                        ////////////////////\n\n                        formData = doc.toJSON().data;\n                    }\n\n                    return this.config.httpClient.post(url.join('/'), formData).pipe(\n\n                        switchMap(res => doc.atomicPatch({\n                            method: 'GET',\n                            data: res,\n                            error: null,\n                            time: new Date().getTime()\n                        })),\n\n                        catchError(err => {\n\n                            return from(doc.atomicPatch({error: JSON.stringify(err)})).pipe(\n\n                                finalize(() => this.retryChange.next(false)),\n                            );\n                        }),\n\n                    );\n\n                } else if (doc.method === 'PUT') {\n\n                    let formData: FormData | {};\n\n                    if (doc.fileFields.length) {\n\n                        //////////////////\n                        // Multipart/form\n                        //////////////////\n\n                        formData = createFormData(doc.toJSON().data) as FormData;\n\n                        doc.fileFields.forEach(k => {\n\n                            (formData as FormData).delete(k.fileField);\n\n                            (formData as FormData).delete(k.fileNameField);\n\n                            (formData as FormData).delete(k.fileType);\n\n                            if (k.fileKeyField && k.fileField && k.fileType) (formData as FormData).append(k.fileKeyField, new File([new Uint8Array(JSON.parse(doc.data[k.fileField])).buffer], k.fileNameField || 'Unknown', {type: k.fileType}));\n                        });\n\n                    } else {\n\n                        ////////////////////\n                        // Application/json\n                        ////////////////////\n\n                        formData = doc.toJSON().data;\n                    }\n\n                    return this.config.httpClient.put(doc.tenantUrl.split('____')[1], formData).pipe(\n\n                        switchMap(res => doc.atomicPatch({\n                            method: 'GET',\n                            data: res,\n                            error: null,\n                            time: new Date().getTime()\n                        })),\n\n                        catchError(err => {\n\n                            return from(doc.atomicPatch({error: JSON.stringify(err)})).pipe(\n\n                                finalize(() => this.retryChange.next(false)),\n                            );\n                        }),\n\n                    );\n\n                } else if (doc.method === 'DELETE') {\n\n                    return this.config.httpClient.delete(doc.tenantUrl.split('____')[1]).pipe(\n\n                        switchMap(() => doc.remove()),\n\n                        catchError(err => {\n\n                            return from(doc.atomicPatch({error: JSON.stringify(err)})).pipe(\n\n                                finalize(() => this.retryChange.next(false)),\n                            );\n                        }),\n\n                    );\n                }\n\n                return throwError(`Document doesn\\'t have valid method. Document: ${JSON.stringify(doc?.toJSON())}`);\n            }),\n\n        );\n\n        return this.retryChange.asObservable().pipe(\n\n            switchMap(trigger => trigger ? hit : of())\n\n        ) as Observable<boolean | PwaDocument<any>>;\n\n    }\n\n    ////////////////////////\n    // Evict Management\n    ////////////////////////\n\n    evict(): Observable<any> {\n\n        return this.storedCollections.pipe(\n\n            switchMap(collectionInfo => {\n\n                const evicts = collectionInfo.map(k => {\n\n                    const cacheAllowedAge = new Date().getTime() - (k.collectionEvictTime * 1000);\n\n                    return k.collection.insert$.pipe(\n\n                        // tslint:disable-next-line: max-line-length\n                        switchMap(() => k.collection.find({selector: {$and: [{method: {$eq: 'GET'}}, {time: {$lt: cacheAllowedAge}}]}}).remove())\n                    );\n\n                });\n\n                return combineLatest(evicts);\n            }),\n        );\n\n    }\n\n    // tslint:disable-next-line: max-line-length\n    skipTrim(): Observable<any> {\n\n        return this.storedCollections.pipe(\n\n            switchMap((collectionInfo) => {\n\n                const skipTrims = collectionInfo.map(k => {\n\n                    return k.collection.insert$.pipe(\n\n                        // tslint:disable-next-line: max-line-length\n                        switchMap(() => k.collection.find({selector: {method: {$eq: 'GET'}}, sort: [{time: 'desc'}], skip: k.collectionSkipDocuments}).remove())\n                    );\n                });\n\n                return combineLatest(skipTrims);\n            }),\n        );\n    }\n\n    ////////////////////////\n    // Conflict Management\n    ////////////////////////\n\n    createNew(doc: PwaDocument<any>): Observable<PwaDocument<any>> {\n\n        if (!!doc && doc.method !== 'GET' && doc.method !== 'POST') {\n\n            return from(doc.atomicPatch({method: 'POST'}));\n        }\n\n        return throwError(`Cannot duplicate this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n    }\n\n    deleteConflict(doc: PwaDocument<any>): Observable<boolean> {\n\n        if (!!doc && doc.method !== 'GET') {\n\n            return from(doc.remove());\n        }\n\n        return throwError(`Cannot delete this document. Document: ${JSON.stringify(doc?.toJSON() || {})}`);\n    }\n}\n\n\nexport function createFormData(object: Object, form?: FormData, namespace?: string): FormData {\n\n    let formData = form || new FormData();\n\n    for (let propertyName in object) {\n\n        const formKey = namespace ? `${namespace}.${propertyName}` : propertyName;\n\n        if (object[propertyName] instanceof Date) {\n\n            formData.append(formKey, object[propertyName].toISOString());\n\n        } else if (object[propertyName] instanceof Array) {\n\n            object[propertyName].forEach((element: any, index: number) => {\n\n                const tempFormKey = `${formKey}-${index}`;\n\n                if (typeof element === 'object') {\n\n                    createFormData(element, formData, tempFormKey);\n\n                } else {\n\n                    formData.append(tempFormKey, element.toString());\n                }\n\n            });\n\n        } else if (typeof object[propertyName] === 'object' && !(object[propertyName] instanceof File) && object[propertyName] !== null && object[propertyName] !== undefined) {\n\n            createFormData(object[propertyName], formData, formKey);\n\n        } else {\n\n            formData.append(formKey, object[propertyName] === null || object[propertyName] === undefined ? '' : object[propertyName].toString());\n        }\n    }\n\n    return formData;\n\n    // const formData = form || new FormData();\n\n    // for (const property in object) {\n\n    //     let formKey = '';\n\n    //     if (isArray) {\n\n    //         formKey = namespace ? `${namespace}[${property}]` : property;\n\n    //     } else {\n\n    //         formKey = namespace ? `${namespace}.${property}` : property;\n    //     }\n\n    //     if (object[property] instanceof Date) {\n\n    //         formData.append(formKey, object[property].toISOString());\n\n    //     } else if (typeof object[property] === 'object' && !(object[property] instanceof File) && object[property] !== null && object[property] !== undefined) {\n\n    //         createFormData(object[property], formData, formKey, typeof object[property] === 'object' && Array.isArray(object[property]));\n\n    //     } else {\n\n    //         formData.append(formKey, object[property] === null || object[property] === undefined ? '' : object[property]);\n    //     }\n    // }\n\n    // return formData;\n}\n","import { addPouchPlugin, addRxPlugin, createRxDatabase, getRxStoragePouch, RxDatabase, RxDatabaseCreator } from 'rxdb';\nimport { from, Observable } from 'rxjs';\nimport { RxDBEncryptionPlugin } from 'rxdb/plugins/encryption';\nimport { RxDBLeaderElectionPlugin } from 'rxdb/plugins/leader-election';\nimport { RxDBValidatePlugin } from 'rxdb/plugins/validate';\nimport { first, map, shareReplay, startWith, switchMap } from 'rxjs/operators';\n\naddPouchPlugin(require('pouchdb-adapter-idb'));\n\n\nexport interface SyncDatabaseServiceCreator {\n    dbCreator: Partial<RxDatabaseCreator>;\n}\n\n\nexport class SyncDatabaseService {\n\n    // tslint:disable-next-line: variable-name\n    private _db$: Observable<RxDatabase<any>>;\n\n    constructor(private _config: SyncDatabaseServiceCreator) {}\n\n    get db$(): Observable<RxDatabase<any>> {\n\n        if (this._db$) { return this._db$; }\n\n        // add encryption plugin\n        addRxPlugin(RxDBEncryptionPlugin);\n\n        // add leader election plugin\n        addRxPlugin(RxDBLeaderElectionPlugin);\n\n        // add schema validate plugin\n        addRxPlugin(RxDBValidatePlugin);\n\n        const pouchAdapter = getRxStoragePouch('idb');\n\n        pouchAdapter.pouchSettings.revs_limit       = 0,\n        pouchAdapter.pouchSettings.auto_compaction  = true;\n\n        this._db$ = from(createRxDatabase({\n            name: 'synchronise/pwadb',\n            storage: pouchAdapter,\n            password: 'ubT6LIL7ne2bdpze0V1DaeOGKKqYMWVF',\n            multiInstance: true,\n            eventReduce: true,\n            ...this._config.dbCreator\n        })).pipe(\n\n            switchMap((db: any) => from(db.waitForLeadership()).pipe(\n\n                startWith(null),\n\n                map(() => db),\n            )),\n\n            shareReplay(1),\n\n            first(),\n\n        );\n\n        return this._db$;\n    }\n\n}\n\n"],"names":["filter"],"mappings":"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"}}}